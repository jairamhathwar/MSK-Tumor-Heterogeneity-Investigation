---
title: "R Notebook"
output: html_notebook
---
```{r}
# importing files to use and restricting analysis to just MSK-IMPACT cases
MAF = read.delim('data_mutations_extended_somatic.oncokb.txt', header = TRUE, sep = "\t")
CNA = read.delim('data_CNA.oncokb.txt', header = TRUE, sep = "\t")
SV = read.delim('data_sv.oncokb.txt', header = TRUE, sep = "\t")
Clinical = read.delim('data_clinical_sample_somatic.oncokb.txt', header = TRUE, sep = "\t")
Dates = read.csv('date_of_surgical_procedure.csv')

Clinical <- Clinical[!(Clinical$GENE_PANEL %in% c("IMPACT-HEME-468", "IMPACT-HEME-400", "ACCESS129")),]
```

```{r}
# constants used throughout this analysis
TUMOR_PURITY_THRESH <- 20 # tumor purity threshold for analysis
SYNC_MARK <- 90 # synchronous samples demarcation of 90 days
ASYNC_MARK <- 120 # asynchronous samples demarcation of 120 days
ASYNC_MAX_DIFF <- 3650 # only consider asynchronous sample pairs within 10 years of each other
BONFERRONI_CORR <- 10 # correction for multiple hypothesis testing across studied cancer types

# libraries used in this analysis
library(ggplot2)
library(tidyverse)
library(dplyr)
library(cowplot)
library(tidyr)
library(reshape2)
```

```{r}
# Count the number of patients with >1 primary samples, >1 metastatic samples, >=1 of both. Count whether the patients have synchronous sample pairs (<=90 days apart) or asynchronous sample pairs (>120 days apart)
# go through each distinct cancer type in Clinical dataset and subset Clinical dataframe for that individual cancer type
distinct_cancer_types <- unique(Clinical$CANCER_TYPE)

# stores counts of number of patients under each condition
Greater_one_prim <- c()
Greater_one_met <- c()
Geq_one_both <- c()

# stores counts of number of patients with synchronous counts under each condition
Prim_sync <- c()
Met_sync <- c()
Both_sync <- c()

# stores counts of number of patients with asynchronous counts under each condition
Prim_async <- c()
Met_async <- c()
Both_async <- c()

# cancer types with the most number of patients in them (determined by running this chunk and then choosing cancer types with >50 patients in category of having atleast 1 primary and met)
common_cancer_type <- c("Non-Small Cell Lung Cancer", "Breast Cancer", "Prostate Cancer", "Bladder Cancer", "Colorectal Cancer", "Soft Tissue Sarcoma", "Glioma")

# n most popular cancer types lists of samples
n <- 14
prim <- vector("list", n)
met <- vector("list", n)
both <- vector("list", n)

# filter by each individual cancer type (replace common_cancer_type with distinct_cancer_types for overall table)
for (i in 1:length(distinct_cancer_types)){
  row_ind <- which(Clinical$CANCER_TYPE == distinct_cancer_types[i])
  subset_gene_data <- Clinical[row_ind,]
  distinct_patients <- unique(subset_gene_data$PATIENT_ID)
  count_primary <- 0
  count_met <- 0
  count_both <- 0
  
  num_prim_sync <- 0
  num_met_sync <- 0
  num_both_sync <- 0
  
  num_prim_async <- 0
  num_met_async <- 0
  num_both_async <- 0
  
  # filters for each patient for each cancer type
  for (j in 1:length(distinct_patients)) {
    patient_indices <- which(subset_gene_data$PATIENT_ID == distinct_patients[j])
    
    # only concerned with patients with multiple samples of same cancer types
    if (length(patient_indices) <=1) {
      next
    }
    num_primary <- 0
    num_met <- 0
    num_both <- 0
    
    prim_start_date <- c()
    met_start_date <- c()
    
    # assignment of counts of number of primary/metastatic for each patient along with start dates
    for (k in patient_indices) {
      # if sample type from patient is primary, increments and stores start date for sample
      if(subset_gene_data$SAMPLE_TYPE[k] == "Primary" && subset_gene_data$TUMOR_PURITY[k] >TUMOR_PURITY_THRESH && !is.na(match(subset_gene_data$SAMPLE_ID[k], Dates$SAMPLE_ID))) {
        num_primary <- num_primary + 1
        row_date_prim <- which(Dates$SAMPLE_ID == subset_gene_data$SAMPLE_ID[k])
        prim_start_date[subset_gene_data$SAMPLE_ID[k]] <- Dates$START_DATE[row_date_prim]
      }
      # if sample type from patient is metastatic, increments and stores start date for sample
      if (subset_gene_data$SAMPLE_TYPE[k] == "Metastasis" && subset_gene_data$TUMOR_PURITY[k] > TUMOR_PURITY_THRESH && !is.na(match(subset_gene_data$SAMPLE_ID[k], Dates$SAMPLE_ID))){
        num_met <- num_met + 1
        row_date_met <- which(Dates$SAMPLE_ID == subset_gene_data$SAMPLE_ID[k])
        met_start_date[subset_gene_data$SAMPLE_ID[k]] <- Dates$START_DATE[row_date_met]
      }
    }
    # sorts the named vectors containing the samples' start dates
    sorted_prim_start <- sort(prim_start_date)
    sorted_met_start <- sort(met_start_date)
    
    num_both <- min(num_primary, num_met)

    # primary synchronous and asynchronous patient counting
    if(num_primary > 1) {
      # increment # patients with >1 primary samples
      count_primary = count_primary + 1
      
      # Calculate the differences between adjacent dates
      date_diffs <- diff(sorted_prim_start)
      
      # Check if any of the differences are less than or equal to SYNC_MARK days
      has_within_sync_prim_days <- any(date_diffs <= SYNC_MARK)
      # increments sync counter 
      if (has_within_sync_prim_days == TRUE) {
        num_prim_sync <- num_prim_sync + 1
      }
      
      # Check if max difference is greater than ASYNC_MARK days and increments async counter
      else if(sorted_prim_start[[length(sorted_prim_start)]] - sorted_prim_start[[1]] > ASYNC_MARK) {
        num_prim_async <- num_prim_async + 1
      }

      # if cancer type relevant then add samples to appropriate vector
      if (distinct_cancer_types[i] %in% common_cancer_type) {
        cancer_index <- which(common_cancer_type == distinct_cancer_types[i])
        prim[[cancer_index]] <- c(prim[[cancer_index]], names(sorted_prim_start))
      }
    }

    # met synchronous and asynchronous patient counting
    if (num_met > 1) {
      count_met = count_met + 1
      
      # Calculate the differences between adjacent dates
      date_diffs <- diff(sorted_met_start)
      
      # Check if any of the differences are less than or equal to SYNC_MARK days
      has_within_sync_met_days <- any(date_diffs <= SYNC_MARK)
      # increments sync counter 
      if (has_within_sync_met_days == TRUE) {
        num_met_sync <- num_met_sync + 1
      }
      
      # Check if max difference is greater than ASYNC_MARK days and increments async counter
      else if(sorted_met_start[[length(sorted_met_start)]] - sorted_met_start[[1]] > ASYNC_MARK) {
        num_met_async <- num_met_async + 1
      }
      
      # if cancer type relevant then add samples to appropriate vector
      if (distinct_cancer_types[i] %in% common_cancer_type) {
        cancer_index <- which(common_cancer_type == distinct_cancer_types[i])
        met[[cancer_index]] <- c(met[[cancer_index]], names(sorted_met_start))
      }
    }

    # 1 of both synchronous and asynchronous patient counting
    if (num_both >= 1) {
      count_both = count_both + 1
      
      # find minimum date interval between sorted_prim_start and sorted_met_start to check if within SYNC_MARK
      index_prim <- 1
      index_met <- 1
      min_interval <- Inf
      
      # Go through the two sorted vectors and find the minimum interval
      while (index_prim <= length(sorted_prim_start) & index_met <= length(sorted_met_start)) {
        interval <- abs(sorted_prim_start[index_prim] - sorted_met_start[index_met])
        
        # Update min_interval and min_interval_indices if the new interval is smaller
        if (as.numeric(interval) < min_interval) {
          min_interval <- as.numeric(interval)
        }
        
        # Move the index of the vector with the smaller date
        if (sorted_prim_start[index_prim] <= sorted_met_start[index_met]) {
          index_prim <- index_prim + 1
        } else {
          index_met <- index_met + 1
        }
      }
      
      if(min_interval <= SYNC_MARK){
        num_both_sync <- num_both_sync + 1
      }
      # find max date interval between sorted_prim_start and sorted_met_start to check if in ASYNC_MARK
      else if(sorted_met_start[[length(sorted_met_start)]] - sorted_prim_start[[1]] > ASYNC_MARK || sorted_prim_start[[length(sorted_prim_start)]] - sorted_met_start[[1]] > ASYNC_MARK) {
        num_both_async <- num_both_async + 1
      }
      
      if(distinct_cancer_types[i] %in% common_cancer_type) {
        both_samples <- c(names(sorted_prim_start), names(sorted_met_start))
        cancer_index <- which(common_cancer_type == distinct_cancer_types[i])
        both[[cancer_index]] <- c(both[[cancer_index]], both_samples)
      }
    }
  }
  
  Greater_one_prim <- append(Greater_one_prim, count_primary)
  Greater_one_met <- append(Greater_one_met, count_met)
  Geq_one_both <- append(Geq_one_both, count_both)
  Prim_sync <- append(Prim_sync, num_prim_sync)
  Met_sync <- append(Met_sync, num_met_sync)
  Both_sync <- append(Both_sync, num_both_sync)
  Prim_async <- append(Prim_async, num_prim_async)
  Met_async <- append(Met_async, num_met_async)
  Both_async <- append(Both_async, num_both_async)
}

df <- data.frame(
  Cancer_Type = distinct_cancer_types,
  Greater_One_Prim = Greater_one_prim,
  Greater_One_Met = Greater_one_met,
  Geq_One_Both = Geq_one_both,
  Prim_Sync = Prim_sync,
  Met_Sync = Met_sync,
  Both_Sync = Both_sync,
  Prim_Async = Prim_async,
  Met_Async = Met_async,
  Both_Async = Both_async
)

# removes rows where all values are 0
to_remove <- apply(df[,2:ncol(df)], 1, function(x) all(x==0))
df <- subset(df, !to_remove)
df <- data.frame(df, row.names = NULL)

# subset dataframe to those cancer types of interest
subset_df <- df[df$Cancer_Type %in% common_cancer_type, ]
subset_df <- subset_df[order(subset_df$Geq_One_Both, decreasing = TRUE),]
subset_df <- data.frame(subset_df, row.names = NULL)

print(subset_df)
```

```{r}
# create master patient table with all sampleIDs and pairs used in this analysis along with time differences between pairs (pairs of primaries, pairs of met, pairs of both)
first_sample <- c()
second_sample <- c()
diff_dates <- c()
for (d in 1:length(common_cancer_type)) {
  cancer_type_studied <- unique(both[[d]])
  num_rows <- length(cancer_type_studied)
  
  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  date_acquired <- integer(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- cancer_type_studied[i]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Dates$PATIENT_ID[patient_ID_index]
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  }
  # create a table with 4 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, date_acquired)
  distinct_patients <- unique(patient_ID)
  
   for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    
    # Nested loops to find pairs with valid intervals and increment num_pairs
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):(nrow(subset_table))) {
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        
        k_sample_type <- Clinical$SAMPLE_TYPE[row_ind_k]
        j_sample_type <- Clinical$SAMPLE_TYPE[row_ind_j]
        
        if((k_sample_type == "Primary" && j_sample_type == "Metastasis") || (k_sample_type == "Metastasis" && j_sample_type == "Primary")) {
          # check to make sure time interval within the correct bounds
          time_difference <- sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])
          if(time_difference > ASYNC_MAX_DIFF) {
            next
          }
          diff_dates <- append(diff_dates, time_difference)
          first_sample <- append(first_sample, subset_table$sample_ID[j])
          second_sample <- append(second_sample, subset_table$sample_ID[k])
        }
      }
    }
   }
}
df <- data.frame(FirstSample = first_sample, SecondSample = second_sample, TimeDifference = diff_dates)
write.csv(df, file = 'bothprimaryandmetsamplepairs.csv')
```

```{r}
# total patient counts across the 3 categories meeting threshold of 50 patients in Geq_One_Both (>=1 primary,metastatic sample) category
subset_df <- subset_df[order(subset_df$Geq_One_Both, decreasing = FALSE),]
x2 <- subset_df %>% 
  select(Cancer_Type, Greater_One_Prim, Greater_One_Met, 
         Geq_One_Both)

x2$Cancer_Type <- factor(x2$Cancer_Type, levels = subset_df$Cancer_Type)

x3 <- x2 %>%
  pivot_longer(cols = -Cancer_Type) %>%
  mutate(type = case_when(
    str_detect(name, "One_Prim") ~ ">1 Primary",
    str_detect(name, "One_Met") ~ ">1 Metastasis",
    str_detect(name, "Geq_One") ~ "\u2265 1 Both"
  ))

# Reorder the levels in the 'type' column
x3$type <- factor(x3$type, levels = c(">1 Primary", ">1 Metastasis", "\u2265 1 Both"))

ggplot(x3, aes(x = value, y = Cancer_Type)) + 
  geom_bar(stat = "identity", aes(fill = type)) + 
  xlab("Patient Counts") +
  ylab("Cancer Type") +
  # ggtitle("Patient Counts") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 30)) +
  theme(axis.text.x = element_text(size = 30)) +
  theme(legend.position = "none") +
  theme(legend.text =element_text(size = 30)) +
  theme(plot.title = element_text(hjust = 0.5)) +  # Center the title
  theme(title = element_text(size = 30)) +
  theme(strip.text.x = element_text(size = 30)) +
  facet_grid(. ~ type, scales = "free_x")
```

```{r}
# plot patient counts with synchronous annotations
x2 <- subset_df %>% 
  select(Cancer_Type, Prim_Async, Prim_Sync, Met_Async, 
         Met_Sync, Both_Async, Both_Sync)

x2$Cancer_Type <- factor(x2$Cancer_Type, levels = subset_df$Cancer_Type)

x3 <- x2 %>%
  pivot_longer(cols = -Cancer_Type) %>%
  mutate(type = case_when(
    str_detect(name, "Prim") ~ ">1 Primary",
    str_detect(name, "Met") ~ ">1 Metastasis",
    str_detect(name, "Both") ~ "\u2265 1 Both"
  )) %>%
  mutate(Status = case_when(
    name %in% c("Prim_Async", "Met_Async", "Both_Async")  ~ "Asynchronous",
    name %in% c("Prim_Sync", "Met_Sync", "Both_Sync") ~ "Synchronous",
  )) %>% 
  filter(!is.na(Status)) 

# Reorder the levels in the 'type' column
x3$type <- factor(x3$type, levels = c(">1 Primary", ">1 Metastasis", "\u2265 1 Both"))

# Define colors for the legend categories
legend_colors <- c("Synchronous" = "blue", "Asynchronous" = "orange")

ggplot(x3, aes(x = value, y = Cancer_Type, fill = Status)) + 
  geom_bar(stat = "identity") + 
  xlab("Patient Counts") +
  ylab("Cancer Type") +
  # ggtitle("Patient Counts with Synchronous Annotations") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 30)) +
  theme(axis.text.x = element_text(size = 30)) +
  theme(legend.position = "top") +
  theme(legend.text =element_text(size = 30)) +
  theme(plot.title = element_text(hjust = 0.5)) +  # Center the title
  theme(title = element_text(size = 30)) +
  theme(strip.text.x = element_text(size = 30)) +
  facet_grid(. ~ type, scales = "free_x")+
  scale_fill_manual(values = legend_colors) +
  labs(fill = "")
```

```{r}
# Restricting Prostate to PRAD, Lung to LUAD and LUSC, COAD to MSI and MSS, and Breast to Ductal and Lobular
# PRAD (8)
PRAD <- 8
for (i in 1:length(prim[[3]])) {
  row_index <- which(Clinical$SAMPLE_ID == prim[[3]][i])
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Prostate Adenocarcinoma") {
    prim[[PRAD]] <- append(prim[[PRAD]], prim[[3]][i])
  }
}
for (i in 1:length(met[[3]])) {
  row_index <- which(Clinical$SAMPLE_ID == met[[3]][i])
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Prostate Adenocarcinoma") {
    met[[PRAD]] <- append(met[[PRAD]], met[[3]][i])
  }
}
for (i in 1:length(both[[3]])) {
  row_index <- which(Clinical$SAMPLE_ID == both[[3]][i])
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Prostate Adenocarcinoma") {
    both[[PRAD]] <- append(both[[PRAD]], both[[3]][i])
  }
}

# LUAD (9), LUSC (10)
LUAD <- 9
LUSC <- 10
for (i in 1:length(prim[[1]])) {
  row_index <- which(Clinical$SAMPLE_ID == prim[[1]][i])
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Lung Adenocarcinoma") {
    prim[[LUAD]] <- append(prim[[LUAD]], prim[[1]][i])
  }
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Lung Squamous Cell Carcinoma") {
    prim[[LUSC]] <- append(prim[[LUSC]], prim[[1]][i])
  }
}
for (i in 1:length(met[[1]])) {
  row_index <- which(Clinical$SAMPLE_ID == met[[1]][i])
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Lung Adenocarcinoma") {
    met[[LUAD]] <- append(met[[LUAD]], met[[1]][i])
  }
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Lung Squamous Cell Carcinoma") {
    met[[LUSC]] <- append(met[[LUSC]], met[[1]][i])
  }
}
for (i in 1:length(both[[1]])) {
  row_index <- which(Clinical$SAMPLE_ID == both[[1]][i])
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Lung Adenocarcinoma") {
    both[[LUAD]] <- append(both[[LUAD]], both[[1]][i])
  }
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Lung Squamous Cell Carcinoma") {
    both[[LUSC]] <- append(both[[LUSC]], both[[1]][i])
  }
}

# COAD MSI (11), COAD MSS(12)
COAD_MSI <- 11
COAD_MSS <- 12
for (i in 1:length(prim[[5]])) {
  row_index <- which(Clinical$SAMPLE_ID == prim[[5]][i])
  if(Clinical$MSI_TYPE[row_index] == "Instable") {
    prim[[COAD_MSI]] <- append(prim[[COAD_MSI]], prim[[5]][i])
  }
  if(Clinical$MSI_TYPE[row_index] == "Stable") {
    prim[[COAD_MSS]] <- append(prim[[COAD_MSS]], prim[[5]][i])
  }
}
for (i in 1:length(met[[5]])) {
  row_index <- which(Clinical$SAMPLE_ID == met_5[i])
  if(Clinical$MSI_TYPE[row_index] == "Instable") {
    met[[COAD_MSI]] <- append(met[[COAD_MSI]], met[[5]][i])
  }
  if(Clinical$MSI_TYPE[row_index] == "Stable") {
    met[[COAD_MSS]] <- append(met[[COAD_MSS]], met[[5]][i])
  }
}
for (i in 1:length(both[[5]])) {
  row_index <- which(Clinical$SAMPLE_ID == both[[5]][i])
  if(Clinical$MSI_TYPE[row_index] == "Instable") {
    both[[COAD_MSI]] <- append(both[[COAD_MSI]], both[[5]][i])
  }
  if(Clinical$MSI_TYPE[row_index] == "Stable") {
    both[[COAD_MSS]] <- append(both[[COAD_MSS]], both[[5]][i])
  }
}

# Ductal Carcinoma (13), Lobluar Carcinoma (14)
DUCTAL <- 13
LOBULAR <- 14
for (i in 1:length(prim[[2]])) {
  row_index <- which(Clinical$SAMPLE_ID == prim[[2]][i])
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Breast Invasive Ductal Carcinoma") {
    prim[[DUCTAL]] <- append(prim[[DUCTAL]], prim[[2]][i])
  }
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Breast Invasive Lobular Carcinoma") {
    prim[[LOBULAR]] <- append(prim[[LOBULAR]], prim[[2]][i])
  }
}
for (i in 1:length(met[[2]])) {
  row_index <- which(Clinical$SAMPLE_ID == met[[2]][i])
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Breast Invasive Ductal Carcinoma") {
    met[[DUCTAL]] <- append(met[[DUCTAL]], met[[2]][i])
  }
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Breast Invasive Lobular Carcinoma") {
    met[[LOBULAR]] <- append(met[[LOBULAR]], met[[2]][i])
  }
}
for (i in 1:length(both[[2]])) {
  row_index <- which(Clinical$SAMPLE_ID == both[[2]][i])
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Breast Invasive Ductal Carcinoma") {
    both[[DUCTAL]] <- append(both[[DUCTAL]], both[[2]][i])
  }
  if(Clinical$CANCER_TYPE_DETAILED[row_index] == "Breast Invasive Lobular Carcinoma") {
    both[[LOBULAR]] <- append(both[[LOBULAR]], both[[2]][i])
  }
}

cancer_type_added <- c("Non-Small Cell Lung Cancer", "Breast Cancer", "Prostate Cancer", "Bladder Cancer", "Colorectal Cancer", "Soft Tissue Sarcoma", "Glioma", "Prostate Adenocarcinoma", "Lung Adenocarcinoma", "Lung Squamous Cell Carcinoma", "Colorectal Unstable", "Colorectal Stable", "Breast Invasive Ductal Carcinoma", "Breast Invasive Lobular Carcinoma")
```

```{r}
# TMB analysis over time singular plot for pairs of primaries or pairs of mets
diff_dates <- c()
diff_TMB <- c()
cancer_type_studied <- unique(met[[LUAD]])
num_pairs <- 0
num_rows <- length(cancer_type_studied)

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)
TMB <- numeric(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type_studied[i]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Dates$PATIENT_ID[patient_ID_index]
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  TMB_row_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  TMB[i] <- Clinical$CVR_TMB_SCORE[TMB_row_ind]
}

# create a table with 4 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired, TMB)

distinct_patients <- unique(patient_ID)
for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  
  # Nested loops to find pairs with valid intervals and increment num_pairs
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      if(!is.na(sum(subset_table$TMB[k], -subset_table$TMB[j]))) {
        # check to make sure time interval within the correct bounds
        time_difference <- sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])
        if(time_difference > ASYNC_MAX_DIFF || time_difference <= ASYNC_MARK) {
          next
        }
        num_pairs <- num_pairs + 1
        diff_dates <- append(diff_dates, time_difference)
        diff_TMB <- append(diff_TMB, sum(subset_table$TMB[k], -subset_table$TMB[j]))
      }
    }
  }
}

# obtain Spearman's rank correlation
spearman_coef <- cor.test(diff_dates, diff_TMB, method = "spearman")
p_value <- spearman_coef$p.value
p_value <- p_value * BONFERRONI_CORR # Bonferroni correction for multiple hypothesis testing
p_value <- round(p_value, digits = 2)
if (p_value < 0.01) {
  p_value = "<0.01"
}

data <- data.frame(x = diff_dates, y = diff_TMB)
scatter_plot <- ggplot(data, aes(x = x, y = y)) +
  geom_point(color = "red", size = 10) +
  geom_smooth(method = "lm", se = FALSE, size = 5) +
  labs(
    # title = paste0("Lung Adenocarcinoma Difference in TMB over Time (N = ", num_pairs, ")"),
    x = "\u0394 Time (Days)", y = "\u0394 TMB") +
  # labs(caption = paste0("p-value: ", p_value)) +
  theme_minimal()+
  # theme(plot.caption = element_text(size = 40)) +
  theme(plot.title = element_text(size = 40)) +
  theme(axis.text.x = element_text(size = 70))+
  theme(axis.text.y = element_text(size = 70)) + 
  theme(axis.title.x = element_text(size = 80)) +
  theme(axis.title.y = element_text(size = 80))+
  theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot

# png("TMBprimLUAD.png", width = 2300, height = 1300)
scatter_plot
# dev.off()
```

```{r}
# FGA analysis FGA values obtained from cBioPortal for relevant cancer types studied
concatenated_prim <- unlist(prim)
concatenated_met <- unlist(met)
concatenated_both <- unlist(both)

all <- c(concatenated_prim, concatenated_met, concatenated_both)
# write.csv(all, file = 'allsamplesFGA.csv')

all <- read.delim('mskimpact_clinical_data_all.tsv', header = TRUE, sep = "\t")
```

```{r}
# FGA analysis over time singular plot for pairs of primaries or pairs of mets
diff_dates <- c()
diff_FGA <- c()
cancer_type_studied <- unique(prim[[PRAD]])
num_rows <- length(cancer_type_studied)
num_pairs <- 0

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)
FGA <- numeric(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type_studied[i]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Dates$PATIENT_ID[patient_ID_index]
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  FGA_row_ind <- which(all$Sample.ID == sample_ID[i])
  FGA[i] <- all$Fraction.Genome.Altered[FGA_row_ind]
}

# create a table with 4 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired, FGA)

distinct_patients <- unique(patient_ID)
for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  
  # Nested loops to find pairs with valid intervals and increment num_pairs
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):nrow(subset_table)) {
      if(!is.na(sum(subset_table$FGA[k], -subset_table$FGA[j]))) {
        time_difference <- sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])
        if(time_difference > ASYNC_MAX_DIFF || time_difference <= ASYNC_MARK) {
          next
        }
        num_pairs <- num_pairs + 1
        diff_dates <- append(diff_dates, time_difference)
        diff_FGA <- append(diff_FGA, sum(subset_table$FGA[k], -subset_table$FGA[j]))
      }
    }
  }
}

# obtain Spearman's rank correlation
spearman_coef <- cor.test(diff_dates, diff_FGA, method = "spearman")
p_value <- spearman_coef$p.value
p_value <- p_value * BONFERRONI_CORR # Bonferroni correction for multiple hypothesis testing
p_value <- round(p_value, digits = 2)
if (p_value < 0.01) {
  p_value = "<0.01"
}

data <- data.frame(x = diff_dates, y = diff_FGA)
scatter_plot <- ggplot(data, aes(x = x, y = y)) +
  geom_point(color = "blue", size = 10) +
  geom_smooth(method = "lm", se = FALSE, size = 5) +
  # labs(title = paste0("Lung Adenocarcinoma Difference in FGA over Time (N = ", num_pairs, ")"), x = "Difference in Days of Sample Acquisition", y = "Difference in Fraction of Genome Altered") +
  labs(
    # title = paste0("Lung Adenocarcinoma Difference in TMB over Time (N = ", num_pairs, ")"),
    x = "\u0394 Time (Days)", y = "\u0394 FGA") +
  # labs(caption = paste0("p-value: ", p_value)) +
  theme_minimal()+
  # theme(plot.caption = element_text(size = 40)) +
  theme(plot.title = element_text(size = 40)) +
  theme(axis.text.x = element_text(size = 70))+
  theme(axis.text.y = element_text(size = 70)) + 
  theme(axis.title.x = element_text(size = 80)) +
  theme(axis.title.y = element_text(size = 80))+
  theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot

# png("FGAmetLUAD.png", width = 2300, height = 1186)
scatter_plot
# dev.off()
```

```{r}
# TMB analysis over time singular plot for pairs of both
cancer_type_studied <- unique(both[[4]])
diff_dates <- c()
diff_TMB <- c()
num_pairs <- 0

num_rows <- length(cancer_type_studied)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)
TMB <- numeric(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type_studied[i]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Dates$PATIENT_ID[patient_ID_index]
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  TMB_row_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  TMB[i] <- Clinical$CVR_TMB_SCORE[TMB_row_ind]
}

# create a table with 4 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired, TMB)

distinct_patients <- unique(patient_ID)
for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  
  # required in case of refined subtyping where pairs are of different subtype
  if(nrow(subset_table) == 1){
    next
  }
  
  # Nested loops to find pairs with valid intervals and increment num_pairs
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
      row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
      
      k_sample_type <- Clinical$SAMPLE_TYPE[row_ind_k]
      j_sample_type <- Clinical$SAMPLE_TYPE[row_ind_j]
      
      if((k_sample_type == "Primary" && j_sample_type == "Metastasis") || (k_sample_type == "Metastasis" && j_sample_type == "Primary")) {
        if(!is.na(sum(subset_table$TMB[k], -subset_table$TMB[j]))) {
          # check to make sure time interval within the correct bounds
          time_difference <- sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])
          if(time_difference > ASYNC_MAX_DIFF || time_difference <= ASYNC_MARK) {
            next
          }
          if(sum(subset_table$TMB[k], -subset_table$TMB[j]) > 50) {
            next
          }
          num_pairs <- num_pairs + 1
          diff_dates <- append(diff_dates, time_difference)
          diff_TMB <- append(diff_TMB, sum(subset_table$TMB[k], -subset_table$TMB[j]))
        }
      }
    }
  }
}

# obtain Spearman's rank correlation
spearman_coef <- cor.test(diff_dates, diff_TMB, method = "spearman")
p_value <- spearman_coef$p.value
p_value <- p_value * (BONFERRONI_CORR -1) # Bonferroni correction for multiple hypothesis testing
p_value <- round(p_value, digits = 2)
if (p_value < 0.01) {
  p_value = "<0.01"
}

data <- data.frame(x = diff_dates, y = diff_TMB)

scatter_plot <- ggplot(data, aes(x = x, y = y)) +
  geom_point(color = "purple", size = 10) +
  geom_smooth(method = "lm", se = FALSE, size = 5) +
  labs(
    # title = paste0("Lung Adenocarcinoma Difference in TMB over Time (N = ", num_pairs, ")"),
    x = "\u0394 Time (Days)", y = "\u0394 TMB") +
  # labs(caption = paste0("p-value: ", p_value)) + 
  theme_minimal()+
  # theme(plot.caption = element_text(size = 40)) + 
  theme(plot.title = element_text(size = 40)) +
  theme(axis.text.x = element_text(size = 70))+
  theme(axis.text.y = element_text(size = 70)) + 
  theme(axis.title.x = element_text(size = 80)) +
  theme(axis.title.y = element_text(size = 80))+
  theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot

# png("TMBgeqLUAD.png", width = 2300, height = 1186)
scatter_plot
# dev.off()
```

```{r}
# FGA analysis over time singular plot for pairs of both
cancer_type_studied <- unique(both[[6]])
diff_dates <- c()
diff_FGA <- c()
num_pairs <- 0

num_rows <- length(cancer_type_studied)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)
FGA <- numeric(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type_studied[i]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Dates$PATIENT_ID[patient_ID_index]
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  FGA_row_ind <- which(all$Sample.ID == sample_ID[i])
  FGA[i] <- all$Fraction.Genome.Altered[FGA_row_ind]
}

# create a table with 4 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired, FGA)

distinct_patients <- unique(patient_ID)
for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  
  # required in case of refined subtyping where pairs are of different subtype
  if(nrow(subset_table) == 1){
    next
  }
  
  # Nested loops to find pairs with valid intervals and increment num_pairs
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):nrow(subset_table)) {
      row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
      row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
      if((Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") | (Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary")) {
        if(!is.na(sum(subset_table$FGA[k], -subset_table$FGA[j]))) {
          time_difference <- sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])
          if(time_difference > ASYNC_MAX_DIFF || time_difference <= ASYNC_MARK) {
            next
          }
          num_pairs <- num_pairs + 1
          diff_dates <- append(diff_dates, time_difference)
          diff_FGA <- append(diff_FGA, sum(subset_table$FGA[k], -subset_table$FGA[j]))
        }
      }
    }
  }
}

# obtain Spearman's rank correlation
spearman_coef <- cor.test(diff_dates, diff_FGA, method = "spearman")
p_value <- spearman_coef$p.value
p_value <- p_value * BONFERRONI_CORR
FGA_p_value <- append(FGA_p_value, p_value)
p_value <- round(p_value, digits = 2)
if (p_value < 0.01) {
  p_value = "<0.01"
}

data <- data.frame(x = diff_dates, y = diff_FGA)

scatter_plot <- ggplot(data, aes(x = x, y = y)) +
  geom_point(color = "purple", size = 10) +
  geom_smooth(method = "lm", se = FALSE, size = 5) +
  # labs(title = paste0("Lung Adenocarcinoma Difference in FGA over Time (N = ", num_pairs, ")"), x = "Difference in Days of Sample Acquisition", y = "Difference in Fraction of Genome Altered") +
  labs(
    # title = paste0("Lung Adenocarcinoma Difference in TMB over Time (N = ", num_pairs, ")"),
    x = "\u0394 Time (Days)", y = "\u0394 FGA") +
  # labs(caption = paste0("p-value: ", p_value)) + 
  theme_minimal()+
  # theme(plot.caption = element_text(size = 40)) + 
  theme(plot.title = element_text(size = 40)) +
  theme(axis.text.x = element_text(size = 70))+
  theme(axis.text.y = element_text(size = 70)) + 
  theme(axis.title.x = element_text(size = 80)) +
  theme(axis.title.y = element_text(size = 80))+
  theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot

# png("FGAgeqLUAD.png", width = 2300, height = 1186)
scatter_plot
# dev.off()
```

```{r}
# TMB Single figure with 10 panels for pairs of primaries or pairs of mets across relevant cancer types
scatter_plots <- list()
TMB_p_value <- c()
excluded <- c(1,2,3,5)
skipped <- 0
for(d in 1:length(cancer_type_added)) {
  if(d %in% excluded) {
    skipped <- skipped + 1
    next
  }
  
  diff_dates <- c()
  diff_TMB <- c()
  cancer_type_studied <- unique(met[[d]])
  num_pairs <- 0
  num_rows <- length(cancer_type_studied)
  
  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  date_acquired <- integer(num_rows)
  TMB <- numeric(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- cancer_type_studied[i]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Dates$PATIENT_ID[patient_ID_index]
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
    TMB_row_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
    TMB[i] <- Clinical$CVR_TMB_SCORE[TMB_row_ind]
  }
  
  # create a table with 4 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, date_acquired, TMB)
  
  distinct_patients <- unique(patient_ID)
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    
    # Nested loops to find pairs with valid intervals and increment num_pairs
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):(nrow(subset_table))) {
        if(!is.na(sum(subset_table$TMB[k], -subset_table$TMB[j]))) {
          # check to make sure time interval within the correct bounds
          time_difference <- sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])
          if(time_difference > ASYNC_MAX_DIFF || time_difference <= ASYNC_MARK) {
            next
          }
          num_pairs <- num_pairs + 1
          diff_dates <- append(diff_dates, time_difference)
          diff_TMB <- append(diff_TMB, sum(subset_table$TMB[k], -subset_table$TMB[j]))
        }
      }
    }
  }
  if(length(diff_dates) <2) {
    skipped <- skipped + 1
    next
  }
  
  # obtain Spearman's rank correlation
  spearman_coef <- cor.test(diff_dates, diff_TMB, method = "spearman")
  p_value <- spearman_coef$p.value
  # p_value <- p_value 
  # * (BONFERRONI_CORR) # Bonferroni correction for multiple hypothesis testing (spearman only runs 9 times in case of mets)
  TMB_p_value <- append(TMB_p_value, p_value)
  p_value <- round(p_value, digits = 2)
  if (p_value < 0.01) {
    p_value = "<0.01"
  }
  if (p_value > 0.05) {
    p_value = "n.s."
  }
  
  data <- data.frame(x = diff_dates, y = diff_TMB)
  scatter_plot <- ggplot(data, aes(x = x, y = y)) +
    geom_point(color = "red", size = 5) +
    geom_smooth(method = "lm", se = FALSE, size = 2) +
    labs(
      title = paste0("", cancer_type_added[d], " (n = ", num_pairs, ")"),
      x = "\u0394 Time (Days)", y = "\u0394 TMB") +
    labs(caption = paste0("p-value: ", p_value)) +
    theme_minimal()+
    theme(plot.caption = element_text(size = 20)) +
    theme(plot.title = element_text(size = 20)) +
    theme(axis.text.x = element_text(size = 20))+
    theme(axis.text.y = element_text(size = 20)) + 
    theme(axis.title.x = element_text(size = 20)) +
    theme(axis.title.y = element_text(size = 20))+
    theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot
  
  # Add the scatter plot to the list
  scatter_plots[[d - skipped]] <- scatter_plot
}

# Create a single figure with 9 panels
figure <- cowplot::plot_grid(plotlist = scatter_plots, nrow = 3, ncol = 4)

# png("10panelsTMBmet.png", width = 2300, height = 1300)
figure
# dev.off()
```

```{r}
# TMB Single figure with 10 panels for pairs of both
scatter_plots <- list()
TMB_p_value <- c()
excluded <- c(1,2,3,5)
skipped <- 0
for(d in 1:length(cancer_type_added)) {
  if(d %in% excluded) {
    skipped <- skipped + 1
    next
  }
  
  diff_dates <- c()
  diff_TMB <- c()
  cancer_type_studied <- unique(both[[d]])
  num_pairs <- 0
  num_rows <- length(cancer_type_studied)
  
  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  date_acquired <- integer(num_rows)
  TMB <- numeric(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- cancer_type_studied[i]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Dates$PATIENT_ID[patient_ID_index]
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
    TMB_row_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
    TMB[i] <- Clinical$CVR_TMB_SCORE[TMB_row_ind]
  }
  
  # create a table with 4 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, date_acquired, TMB)
  
  distinct_patients <- unique(patient_ID)
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    
    # required in case of refined subtyping where pairs are of different subtype
    if(nrow(subset_table) == 1){
      next
    }
    
    # Nested loops to find pairs with valid intervals and increment num_pairs
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):(nrow(subset_table))) {
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        
        k_sample_type <- Clinical$SAMPLE_TYPE[row_ind_k]
        j_sample_type <- Clinical$SAMPLE_TYPE[row_ind_j]
        
        if((k_sample_type == "Primary" && j_sample_type == "Metastasis") || (k_sample_type == "Metastasis" && j_sample_type == "Primary")) {
          if(!is.na(sum(subset_table$TMB[k], -subset_table$TMB[j]))) {
            # check to make sure time interval within the correct bounds
            time_difference <- sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])
            if(time_difference > ASYNC_MAX_DIFF || time_difference <= ASYNC_MARK) {
              next
            }
            num_pairs <- num_pairs + 1
            diff_dates <- append(diff_dates, time_difference)
            diff_TMB <- append(diff_TMB, sum(subset_table$TMB[k], -subset_table$TMB[j]))
          }
        }
      }
    }
  }
  if(length(diff_dates) <2) {
    skipped <- skipped + 1
    next
  }
  
  # obtain Spearman's rank correlation
  spearman_coef <- cor.test(diff_dates, diff_TMB, method = "spearman")
  p_value <- spearman_coef$p.value
  # p_value <- p_value * (BONFERRONI_CORR - 1) # Bonferroni correction for multiple hypothesis testing (Spearman only runs 9 times)
  TMB_p_value <- append(TMB_p_value, p_value)
  p_value <- round(p_value, digits = 2)
  if (p_value < 0.01) {
    p_value = "<0.01"
  }
  if (p_value > 0.05) {
    p_value = "n.s."
  }
  
  data <- data.frame(x = diff_dates, y = diff_TMB)
  scatter_plot <- ggplot(data, aes(x = x, y = y)) +
    geom_point(color = "purple", size = 5) +
    geom_smooth(method = "lm", se = FALSE, size = 2) +
    labs(
      title = paste0("", cancer_type_added[d], " (n = ", num_pairs, ")"),
      x = "\u0394 Time (Days)", y = "\u0394 TMB") +
    labs(caption = paste0("p-value: ", p_value)) +
    theme_minimal()+
    theme(plot.caption = element_text(size = 20)) +
    theme(plot.title = element_text(size = 20)) +
    theme(axis.text.x = element_text(size = 20))+
    theme(axis.text.y = element_text(size = 20)) + 
    theme(axis.title.x = element_text(size = 20)) +
    theme(axis.title.y = element_text(size = 20))+
    theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot
  
  # Add the scatter plot to the list
  scatter_plots[[d - skipped]] <- scatter_plot
}

# Create a single figure with 9 panels
figure <- cowplot::plot_grid(plotlist = scatter_plots, nrow = 3, ncol = 4)

# png("10panelsTMBmet.png", width = 2300, height = 1300)
figure
# dev.off()
```

```{r}
# FGA Single figure with 10 panels for Pairs of primaries or mets
scatter_plots <- list()
FGA_p_value <- c()
excluded <- c(1,2,3,5)
skipped <- 0
for(d in 1:length(cancer_type_added)) {
  if(d %in% excluded) {
    skipped <- skipped + 1
    next
  }
  
  cancer_type_studied <- unique(met[[d]])
  diff_dates <- c()
  diff_FGA <- c()
  num_pairs <- 0
  
  num_rows <- length(cancer_type_studied)
  if(num_rows < 1) {next}
  
  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  date_acquired <- integer(num_rows)
  FGA <- numeric(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- cancer_type_studied[i]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Dates$PATIENT_ID[patient_ID_index]
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
    FGA_row_ind <- which(all$Sample.ID == sample_ID[i])
    FGA[i] <- all$Fraction.Genome.Altered[FGA_row_ind]
  }
  
  # create a table with 4 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, date_acquired, FGA)
  
  distinct_patients <- unique(patient_ID)
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    
    # required in case of refined subtyping where pairs are of different subtype
    if(nrow(subset_table) == 1){
      next
    }
    
    # Nested loops to find pairs with valid intervals and increment num_pairs
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):nrow(subset_table)) {
        if(!is.na(sum(subset_table$FGA[k], -subset_table$FGA[j]))) {
          time_difference <- sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])
          if(time_difference > ASYNC_MAX_DIFF || time_difference <= ASYNC_MARK) {
            next
          }
          num_pairs <- num_pairs + 1
          diff_dates <- append(diff_dates, time_difference)
          diff_FGA <- append(diff_FGA, sum(subset_table$FGA[k], -subset_table$FGA[j]))
        }
      }
    }
  }
  if(length(diff_dates) <2) {
    skipped <- skipped + 1
    next
  }
  
  # obtain Spearman's rank correlation
  spearman_coef <- cor.test(diff_dates, diff_FGA, method = "spearman")
  p_value <- spearman_coef$p.value
  # p_value <- p_value 
  # * (BONFERRONI_CORR)
  FGA_p_value <- append(FGA_p_value, p_value)
  p_value <- round(p_value, digits = 2)
  if (p_value < 0.01) {
    p_value = "<0.01"
  }
  if (p_value > 0.05) {
    p_value = "n.s."
  }
  
  data <- data.frame(x = diff_dates, y = diff_FGA)
  
  scatter_plot <- ggplot(data, aes(x = x, y = y)) +
    geom_point(color = "red", size = 5) +
    geom_smooth(method = "lm", se = FALSE, size = 2) +
    # labs(title = paste0("Lung Adenocarcinoma Difference in FGA over Time (N = ", num_pairs, ")"), x = "Difference in Days of Sample Acquisition", y = "Difference in Fraction of Genome Altered") +
    labs(
      title = paste0("", cancer_type_added[d], " (n = ", num_pairs, ")"),
      x = "\u0394 Time (Days)", y = "\u0394 FGA") +
    labs(caption = paste0("p-value: ", p_value)) +
    theme_minimal()+
    theme(plot.caption = element_text(size = 20)) +
    theme(plot.title = element_text(size = 20)) +
    theme(axis.text.x = element_text(size = 20))+
    theme(axis.text.y = element_text(size = 20)) + 
    theme(axis.title.x = element_text(size = 20)) +
    theme(axis.title.y = element_text(size = 20))+
    theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot
  
  # Add the scatter plot to the list
  scatter_plots[[d - skipped]] <- scatter_plot
}

# Create a single figure with 9 panels
figure <- cowplot::plot_grid(plotlist = scatter_plots, nrow = 3, ncol = 4)

# png("10panelsTMBgeq.png", width = 2700, height = 1300)
figure
```

```{r}
# FGA Single figure with 10 panels for Pairs of Both
scatter_plots <- list()
excluded <- c(1,2,3,5)
skipped <- 0
FGA_p_value <- c()
for(d in 1:length(cancer_type_added)) {
  if(d %in% excluded) {
    skipped <- skipped + 1
    next
  }
  
  cancer_type_studied <- unique(both[[d]])
  diff_dates <- c()
  diff_FGA <- c()
  num_pairs <- 0
  
  num_rows <- length(cancer_type_studied)
  if(num_rows < 1) {next}
  
  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  date_acquired <- integer(num_rows)
  FGA <- numeric(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- cancer_type_studied[i]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Dates$PATIENT_ID[patient_ID_index]
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
    FGA_row_ind <- which(all$Sample.ID == sample_ID[i])
    FGA[i] <- all$Fraction.Genome.Altered[FGA_row_ind]
  }
  
  # create a table with 4 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, date_acquired, FGA)
  
  distinct_patients <- unique(patient_ID)
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    
    # required in case of refined subtyping where pairs are of different subtype
    if(nrow(subset_table) == 1){
      next
    }
    
    # Nested loops to find pairs with valid intervals and increment num_pairs
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):nrow(subset_table)) {
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        if((Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") | (Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary")) {
          if(!is.na(sum(subset_table$FGA[k], -subset_table$FGA[j]))) {
            time_difference <- sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])
            if(time_difference > ASYNC_MAX_DIFF || time_difference <= ASYNC_MARK) {
              next
            }
            num_pairs <- num_pairs + 1
            diff_dates <- append(diff_dates, time_difference)
            diff_FGA <- append(diff_FGA, sum(subset_table$FGA[k], -subset_table$FGA[j]))
          }
        }
      }
    }
  }
  if(length(diff_dates) <2) {
    skipped <- skipped + 1
    next
  }
  
  # obtain Spearman's rank correlation
  spearman_coef <- cor.test(diff_dates, diff_FGA, method = "spearman")
  p_value <- spearman_coef$p.value
  # p_value <- p_value * (BONFERRONI_CORR - 1)
  FGA_p_value <- append(FGA_p_value, p_value)
  p_value <- round(p_value, digits = 2)
  if (p_value < 0.01) {
    p_value = "<0.01"
  }
  if (p_value > 0.05) {
    p_value = "n.s."
  }
  
  data <- data.frame(x = diff_dates, y = diff_FGA)
  
  scatter_plot <- ggplot(data, aes(x = x, y = y)) +
    geom_point(color = "purple", size = 5) +
    geom_smooth(method = "lm", se = FALSE, size = 2) +
    # labs(title = paste0("Lung Adenocarcinoma Difference in FGA over Time (N = ", num_pairs, ")"), x = "Difference in Days of Sample Acquisition", y = "Difference in Fraction of Genome Altered") +
    labs(
      title = paste0("", cancer_type_added[d], " (n = ", num_pairs, ")"),
      x = "\u0394 Time (Days)", y = "\u0394 FGA") +
    labs(caption = paste0("p-value: ", p_value)) +
    theme_minimal()+
    theme(plot.caption = element_text(size = 20)) +
    theme(plot.title = element_text(size = 20)) +
    theme(axis.text.x = element_text(size = 20))+
    theme(axis.text.y = element_text(size = 20)) + 
    theme(axis.title.x = element_text(size = 20)) +
    theme(axis.title.y = element_text(size = 20))+
    theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot
  
  # Add the scatter plot to the list
  scatter_plots[[d - skipped]] <- scatter_plot
}

# Create a single figure with 9 panels
figure <- cowplot::plot_grid(plotlist = scatter_plots, nrow = 3, ncol = 4)

# png("10panelsTMBgeq.png", width = 2700, height = 1300)
figure
# dev.off()
```

```{r}
# barplot (-log(p_value) vs. cancer type (FGA and TMB categories))
# Compute -log(p-value)
log_TMB_p_values <- -log10(TMB_p_value)
log_FGA_p_values <- -log10(FGA_p_value)

# log_TMB_p_values <- c(log_TMB_p_values[1:(5)], 0, log_TMB_p_values[6:length(log_TMB_p_values)])
# log_TMB_p_values <- c(log_TMB_p_values[1:(6)], 0, log_TMB_p_values[7:length(log_TMB_p_values)])
#
#
# log_FGA_p_values <- c(log_FGA_p_values[1:(5)], 0, log_FGA_p_values[6:length(log_FGA_p_values)])
# log_FGA_p_values <- c(log_FGA_p_values[1:(6)], 0, log_FGA_p_values[7:length(log_FGA_p_values)])
cancer_type <- c("Bladder Cancer", "Soft Tissue Sarcoma", "Glioma", "Prostate Adenocarcinoma", "Lung Adenocarcinoma", "Lung Squamous Cell Carcinoma", "Colorectal Stable", "Breast Invasive Ductal Carcinoma", "Breast Invasive Lobular Carcinoma")

data_TMB <- data.frame(Category = cancer_type, LogPValue = log_TMB_p_values, Dataset = "Dataset 1")
data_FGA <- data.frame(Category = cancer_type, LogPValue = log_FGA_p_values, Dataset = "Dataset 2")

# horizontal line corresponding to p_value = 0.05
threshold <- -log10(0.05/9)

# bonferroni correction
# bon_correction <- -log10(0.05/10)

# Merge datasets
combined_data <- rbind(data_TMB, data_FGA)

ggplot(combined_data, aes(x = Category, y = LogPValue, fill = Dataset))+
  geom_col(position = "dodge") +
  # geom_bar(aes(y = LogPValue, fill = "Dataset 1"), position = "dodge", stat = "identity", alpha = 0.7) +
  # geom_bar(aes(y = LogPValue, fill = "Dataset 2"), position = "dodge", stat = "identity", alpha = 0.7) +
  labs(
    x = NULL,
    # x = "Categories", 
    y = "-log(p-value)",
    fill = ""
    # , title = "-log(p-value) for TMB and FGA for Pairs of 1 Primary and 1 Met"
    ) +
  scale_fill_manual(values = c("blue", "green"),
                    labels = c("TMB", "FGA")) +
  geom_hline(yintercept = threshold, linetype = "dashed", color = "red", size = 3) + 
  theme(text = element_text(size = 50), 
        legend.position = "top") + 
  theme(axis.text.x = element_blank(),  # Remove x-axis labels
        axis.ticks.x = element_blank())  # Remove x-axis ticks
  
  # geom_hline(yintercept = bon_correction, linetype = "dashed", color = "purple")
```


```{r}
# Single figure 10 panels for synchronous samples TMB prim vs. met
excluded <- c(1,2,3,5)
skipped <- 0
box_plots <- list()
TMB_p_value <- c()
for(d in 1:length(cancer_type_added)) {
  if(d %in% excluded) {
    skipped <- skipped + 1
    next
  }
  cancer_type_studied <- unique(both[[d]])
  prim_TMB <- c()
  met_TMB <- c()
  num_pairs <- 0
  
  num_rows <- length(cancer_type_studied)
  if(num_rows < 1) {next}

  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  TMB <- numeric(num_rows)
  date_acquired <- integer(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- cancer_type_studied[i]
    TMB_row_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Clinical$PATIENT_ID[TMB_row_ind]
    TMB[i] <- Clinical$CVR_TMB_SCORE[TMB_row_ind]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  }
  
  # create a table with 3 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, date_acquired, TMB)

  distinct_patients <- unique(patient_ID)
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    
    # required in case of refined subtyping where pairs are of different subtype
    if(nrow(subset_table) == 1){
      next
    }
    
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):(nrow(subset_table))) {
        if((subset_table$date_acquired[k] - subset_table$date_acquired[j]) > SYNC_MARK) {
          next
        }
        
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        if(Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") {
          if(!is.na(subset_table$TMB[k]) & !is.na(subset_table$TMB[j]) ) {
            prim_TMB <- append(prim_TMB, subset_table$TMB[k])
            met_TMB <- append(met_TMB, subset_table$TMB[j])
            num_pairs <- num_pairs+1
          }
        } 
        if(Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary") {
          if(!is.na(subset_table$TMB[k]) & !is.na(subset_table$TMB[j])) {
            prim_TMB <- append(prim_TMB, subset_table$TMB[j])
            met_TMB <- append(met_TMB, subset_table$TMB[k])
            num_pairs <- num_pairs+1
          }
        }
      }
    }
  }
  
  if(length(prim_TMB) < 1) {
    skipped <- skipped + 1
    next
  }
  
  cancer_plot <- cancer_type_added[d]
  # Perform Wilcoxon signed-rank test
  result <- wilcox.test(prim_TMB, met_TMB, paired = TRUE)
  p_value <- result$p.value
  TMB_p_value <- append(TMB_p_value, p_value)
  p_value <- round(p_value, digits =2)
  if (p_value > 0.05) {
    p_value = "n.s."
  }
  
  
  data <- data.frame(Primary = prim_TMB, Metastasis = met_TMB)
  data$Index <- seq_along(prim_TMB)
  # Reshape the data frame into long format
  data_long <- reshape2::melt(data, id.vars = "Index")
  
  # Create a factor variable for the variable column with the desired order
  data_long$variable <- factor(data_long$variable, levels = c("Primary", "Metastasis"))
  
  # data_long <- gather(data, key = "Group", value = "Value", Primary, Metastasis)
  boxplot <- ggplot(data_long, aes(x = variable, y = value, fill = variable)) +
    geom_boxplot() +
    geom_line(aes(group = Index), color = "blue", size = 0.6, alpha = 0.8)+
    labs(
      # x = "Group", 
      x = NULL,
      y = "log(TMB)", title = paste0("", cancer_plot, " (N = ", num_pairs, ")"), caption = paste0("p-value: ", p_value)
      # , fill = "Category"
      ) +
    theme_minimal()+
    # log vertical axis for ease of visualization
    scale_y_log10() +
    theme(plot.caption = element_text(size = 25),
          axis.text.x = element_text(size = 25),
          axis.text.y = element_text(size = 25),
          axis.title.x = element_text(size = 25),
          axis.title.y = element_text(size = 25),
          plot.title = element_text(size = 25),
          legend.position = "none",  # Remove the legend
          panel.border = element_rect(color = "black", size = 2, fill = NA))  # Add a border around the plot
  
  # Add the box plot to the list
  box_plots[[d - skipped]] <- boxplot
}

figure <- cowplot::plot_grid(plotlist = box_plots, nrow = 3, ncol = 4)

# print(figure)

# png("16panelsTMBsyncboxplot.png", width = 2600, height = 1300)
figure
# dev.off()
```

```{r}
# TMB for Bladder Cancer Sync Prim vs. Met
cancer_type_studied <- both_geq_sync_4
prim_TMB <- c()
met_TMB <- c()
num_pairs <- 0

num_rows <- length(cancer_type_studied)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
TMB <- numeric(num_rows)
date_acquired <- integer(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type_studied[i]
  TMB_row_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[TMB_row_ind]
  TMB[i] <- Clinical$CVR_TMB_SCORE[TMB_row_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired, TMB)

distinct_patients <- unique(patient_ID)
for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  # remove patients that only have 1 asynchronous primary sample (means they originally had 3 primary samples but 2 were synchronous and last one not)
  if(nrow(subset_table) == 1) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      if((subset_table$date_acquired[k] - subset_table$date_acquired[j]) > 90) {
        next
      }
      
      row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
      row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
      if(Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") {
        if(!is.na(subset_table$TMB[k]) & !is.na(subset_table$TMB[j]) ) {
          prim_TMB <- append(prim_TMB, subset_table$TMB[k])
          met_TMB <- append(met_TMB, subset_table$TMB[j])
          num_pairs <- num_pairs+1
        }
      } 
      if(Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary") {
        if(!is.na(subset_table$TMB[k]) & !is.na(subset_table$TMB[j])) {
          prim_TMB <- append(prim_TMB, subset_table$TMB[j])
          met_TMB <- append(met_TMB, subset_table$TMB[k])
          num_pairs <- num_pairs+1
        }
      }
    }
  }
}

if(length(prim_TMB) < 1) {next}
cancer_plot <- cancer_type_added[d]
# Perform Wilcoxon signed-rank test
result <- wilcox.test(prim_TMB, met_TMB, paired = TRUE)
p_value <- result$p.value
TMB_p_value <- append(TMB_p_value, p_value)
p_value <- p_value * 10
p_value <- round(p_value, digits =2)

data <- data.frame(Primary = prim_TMB, Metastasis = met_TMB)
data$Index <- seq_along(prim_TMB)
# Reshape the data frame into long format
data_long <- reshape2::melt(data, id.vars = "Index")

# Create a factor variable for the variable column with the desired order
data_long$variable <- factor(data_long$variable, levels = c("Primary", "Metastasis"))

# Define a color palette
# custom_colors <- c("#1f78b4", "#33a02c", "#e31a1c", "#ff7f00", "#6a3d9a", "#b15928")

# data_long <- gather(data, key = "Group", value = "Value", Primary, Metastasis)
boxplot <- ggplot(data_long, aes(x = variable, y = value, fill = variable)) +
  geom_boxplot() + # Adjust width and transparency
  geom_line(aes(group = Index), color = "blue", size = 0.5, alpha = 0.8)+
  labs(x = "Group", y = "log(TMB)", 
       # title = paste0("Bladder Cancer log(TMB) Across Primary and Mets (N = ", num_pairs, ")"), caption = paste0("p-value: ", p_value), 
       fill = "Category") +
  # scale_fill_manual(values = custom_colors) +
  theme_minimal()+
  # log vertical axis for ease of visualization
  scale_y_log10() +
  # theme(plot.caption = element_text(size = 40)) +
  theme(axis.text.x = element_text(size = 70))+
  theme(axis.text.y = element_text(size = 70)) + 
  theme(axis.title.x = element_text(size = 80))+
  theme(axis.title.y = element_text(size = 80)) +
  theme(plot.title = element_text(size = 40)) +
  # theme(legend.text =element_text(size = 25)) +
  # theme(legend.title = element_text(size =25))
  theme(legend.position = "none") +
  theme(panel.border = element_rect(color = "black", size = 2, fill = NA))  # Add a border around the plot

# png("bladdersyncboxplot.png", width = 2600, height = 1300)
boxplot
# dev.off()
```

```{r}
# difference in FGA between the synchronous samples
box_plots <- list()
FGA_p_value <- c()

# acquire geq for SYNCHRONOUS samples do samething
skipped <- 0
for(d in 1:length(cancer_type_added)) {
  if(d %in% excluded) {
    skipped <- skipped + 1
    next
  }
  cancer_type_studied <-unique(both[[d]])
  prim_FGA <- c()
  met_FGA <- c()
  num_pairs <- 0
  
  num_rows <- length(cancer_type_studied)
  if(num_rows < 1) {next}

  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  FGA <- numeric(num_rows)
  date_acquired <- integer(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- cancer_type_studied[i]
    clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
    FGA_row_ind <- which(all$Sample.ID == sample_ID[i])
    patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
    FGA[i] <- all$Fraction.Genome.Altered[FGA_row_ind]
  }
  
  # create a table with 3 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, FGA, date_acquired)

  distinct_patients <- unique(patient_ID)
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    # remove patients that only have 1 asynchronous primary sample (means they originally had 3 primary samples but 2 were synchronous and last one not)
    if(nrow(subset_table) == 1) {
      next
    }
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):(nrow(subset_table))) {
        if((subset_table$date_acquired[k] - subset_table$date_acquired[j]) > SYNC_MARK) {
          next
        }
        
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        if(Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") {
          if(!is.na(subset_table$FGA[k]) & !is.na(subset_table$FGA[j]) ) {
            prim_FGA <- append(prim_FGA, subset_table$FGA[k])
            met_FGA <- append(met_FGA, subset_table$FGA[j])
            num_pairs <- num_pairs+1
          }
        } 
        if(Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary") {
          if(!is.na(subset_table$FGA[k]) & !is.na(subset_table$FGA[j])) {
            prim_FGA <- append(prim_FGA, subset_table$FGA[j])
            met_FGA <- append(met_FGA, subset_table$FGA[k])
            num_pairs <- num_pairs+1
          }
        }
      }
    }
  }
  
  # & subset_table$TMB[k] != "NA" & subset_table$TMB[j] != "NA"
  
  if(length(prim_FGA) < 1) {
    skipped <- skipped + 1
    next
  }
  cancer_plot <- cancer_type_added[d]
  # Perform Wilcoxon signed-rank test
  result <- wilcox.test(prim_FGA, met_FGA, paired = TRUE)
  p_value <- result$p.value
  FGA_p_value <- append(FGA_p_value, p_value)
  p_value <- round(p_value, digits = 2)
  if (p_value > 0.05) {
    p_value = "n.s."
  }
  
  data <- data.frame(Primary = prim_FGA, Metastasis = met_FGA)
  data$Index <- seq_along(prim_FGA)
  # Reshape the data frame into long format
  data_long <- reshape2::melt(data, id.vars = "Index")
  
  # Create a factor variable for the variable column with the desired order
  data_long$variable <- factor(data_long$variable, levels = c("Primary", "Metastasis"))
  
  # data_long <- gather(data, key = "Group", value = "Value", Primary, Metastasis)
  boxplot <- ggplot(data_long, aes(x = variable, y = value, fill = variable)) +
    geom_boxplot() +
    geom_line(aes(group = Index), color = "blue", size = 0.6, alpha = 0.8)+
    labs(
      # x = "Group", 
      x = NULL,
      y = "FGA", title = paste0("", cancer_plot, " (N = ", num_pairs, ")"), caption = paste0("p-value: ", p_value), fill = "Category") +
    theme_minimal() +
    theme(plot.caption = element_text(size = 25),
          axis.text.x = element_text(size = 25),
          axis.text.y = element_text(size = 25),
          axis.title.x = element_text(size = 25),
          axis.title.y = element_text(size = 25),
          plot.title = element_text(size = 25),
          legend.position = "none",  # Remove the legend
          panel.border = element_rect(color = "black", size = 2, fill = NA))  # Add a border around the plot
  
  
  # # Add lines connecting paired points
  # boxplot <- boxplot +
  #   geom_line(aes(group = 1), color = "blue")
  
  # Add the box plot to the list
  box_plots[[d - skipped]] <- boxplot
}

figure <- cowplot::plot_grid(plotlist = box_plots, nrow = 3, ncol = 4)

# png("16panelsFGAsyncboxplot.png", width = 2600, height = 1300)
figure
# dev.off()

# print(figure)
```

```{r}
# barplot containing synchronous characteristics of TMB and FGA
log_TMB_p_values <- -log10(TMB_p_value)
log_FGA_p_values <- -log10(FGA_p_value)

# log_TMB_p_values <- c(log_TMB_p_values[1:(5)], 0, log_TMB_p_values[6:length(log_TMB_p_values)])
# log_TMB_p_values <- c(log_TMB_p_values[1:(6)], 0, log_TMB_p_values[7:length(log_TMB_p_values)])
#
#
# log_FGA_p_values <- c(log_FGA_p_values[1:(5)], 0, log_FGA_p_values[6:length(log_FGA_p_values)])
# log_FGA_p_values <- c(log_FGA_p_values[1:(6)], 0, log_FGA_p_values[7:length(log_FGA_p_values)])
cancer_type <- c("Bladder Cancer", "Soft Tissue Sarcoma", "Glioma", "Prostate Adenocarcinoma", "Lung Adenocarcinoma", "Lung Squamous Cell Carcinoma", "Colorectal Stable", "Breast Invasive Ductal Carcinoma")

data_TMB <- data.frame(Category = cancer_type, LogPValue = log_TMB_p_values, Dataset = "Dataset 1")
data_FGA <- data.frame(Category = cancer_type, LogPValue = log_FGA_p_values, Dataset = "Dataset 2")

# horizontal line corresponding to p_value = 0.05
threshold <- -log10(0.05/8)

# bonferroni correction
# bon_correction <- -log10(0.05/10)

# Merge datasets
combined_data <- rbind(data_TMB, data_FGA)

ggplot(combined_data, aes(x = Category, y = LogPValue, fill = Dataset))+
  geom_col(position = "dodge") +
  # geom_bar(aes(y = LogPValue, fill = "Dataset 1"), position = "dodge", stat = "identity", alpha = 0.7) +
  # geom_bar(aes(y = LogPValue, fill = "Dataset 2"), position = "dodge", stat = "identity", alpha = 0.7) +
  labs(x = "Categories", y = "-log(p-value)",
       title = "-log(p-value) for TMB and FGA for Synchronous Pairs of 1 Primary and 1 Met") +
  scale_fill_manual(values = c("orange", "turquoise"),
                    labels = c("TMB", "FGA")) +
  geom_hline(yintercept = threshold, linetype = "dashed", color = "red", size = 1) + 
  theme(text = element_text(size = 30)) + 
  theme(axis.text.x = element_text(size=10))
```

```{r}
# bladder cancer tumor purity synchronous boxplot
cancer_type_studied <- both_geq_sync_4
prim_purity <- c()
met_purity <- c()
num_pairs <- 0

num_rows <- length(cancer_type_studied)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
tumor_purity <- numeric(num_rows)
date_acquired <- integer(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type_studied[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  tumor_purity[i] <- Clinical$TUMOR_PURITY[clin_ind]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, tumor_purity, date_acquired)

distinct_patients <- unique(patient_ID)
for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  # remove patients that only have 1 asynchronous primary sample (means they originally had 3 primary samples but 2 were synchronous and last one not)
  if(nrow(subset_table) == 1) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      if((subset_table$date_acquired[k] - subset_table$date_acquired[j]) > 90) {
        next
      }
      row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
      row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
      if(Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") {
        if(!is.na(subset_table$tumor_purity[k]) & !is.na(subset_table$tumor_purity[j]) ) {
          prim_purity <- append(prim_purity, subset_table$tumor_purity[k])
          met_purity <- append(met_purity, subset_table$tumor_purity[j])
          num_pairs <- num_pairs+1
        }
      } 
      if(Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary") {
        if(!is.na(subset_table$tumor_purity[k]) & !is.na(subset_table$tumor_purity[j])) {
          prim_purity <- append(prim_purity, subset_table$tumor_purity[j])
          met_purity <- append(met_purity, subset_table$tumor_purity[k])
          num_pairs <- num_pairs+1
        }
      }
    }
  }
}

# & subset_table$TMB[k] != "NA" & subset_table$TMB[j] != "NA"

if(length(prim_purity) < 1) {next}
cancer_plot <- cancer_type_added[d]
# Perform Wilcoxon signed-rank test
prim_purity <- as.numeric(prim_purity)
met_purity <- as.numeric(met_purity)
result <- wilcox.test(prim_purity, met_purity, paired = TRUE)
p_value <- result$p.value
p_value <- p_value * 10
p_value <- round(p_value, digits= 2)

data <- data.frame(Primary = prim_purity, Metastasis = met_purity)
data$Index <- seq_along(prim_purity)
# Reshape the data frame into long format
data_long <- reshape2::melt(data, id.vars = "Index")

# Create a factor variable for the variable column with the desired order
data_long$variable <- factor(data_long$variable, levels = c("Primary", "Metastasis"))

# data_long <- gather(data, key = "Group", value = "Value", Primary, Metastasis)
boxplot <- ggplot(data_long, aes(x = variable, y = value, fill = variable)) +
  geom_boxplot() +
  geom_line(aes(group = Index), color = "blue", size = 0.5, alpha = 0.8) +
  labs(x = "Group", y = "Tumor Purity", title = paste0("Bladder Cancer Tumor Purity Across Primary and Mets (N = ", num_pairs, ")"), caption = paste0("p-value: ", p_value), fill = "Category") +
  theme_minimal() +
  # theme(plot.caption = element_text(size = 40)) +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(size = 70))+
  theme(axis.text.y = element_text(size = 70)) + 
  theme(axis.title.x = element_text(size = 70))+
  theme(axis.title.y = element_text(size = 80)) +
  theme(plot.title = element_text(size = 40)) +
  # theme(legend.text =element_text(size = 25)) +
  # theme(legend.title = element_text(size =25))
  theme(panel.border = element_rect(color = "black", size = 2, fill = NA))  # Add a border around the plot
  
  # theme(legend.text =element_text(size = 25)) +
  # theme(legend.title = element_text(size = 25))

# png("bladdertumorpurity.png", width = 2600, height = 1300)
boxplot
# dev.off()
```


```{r}
# difference in purity between the synchronous samples
box_plots <- list()

# acquire geq for SYNCHRONOUS samples do samething
skipped <- 0
for(d in 1:16) {
  if(d %in% excluded) {
    skipped <- skipped + 1
    next
  }
  cancer_type_studied <- get(paste0("both_geq_sync_", d))
  prim_purity <- c()
  met_purity <- c()
  num_pairs <- 0
  
  num_rows <- length(cancer_type_studied)
  if(num_rows < 1) {next}

  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  tumor_purity <- numeric(num_rows)
  date_acquired <- integer(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- cancer_type_studied[i]
    clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
    tumor_purity[i] <- Clinical$TUMOR_PURITY[clin_ind]
  }
  
  # create a table with 3 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, tumor_purity, date_acquired)

  distinct_patients <- unique(patient_ID)
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    # remove patients that only have 1 asynchronous primary sample (means they originally had 3 primary samples but 2 were synchronous and last one not)
    if(nrow(subset_table) == 1) {
      next
    }
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):(nrow(subset_table))) {
        if((subset_table$date_acquired[k] - subset_table$date_acquired[j]) > 90) {
          next
        }
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        if(Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") {
          if(!is.na(subset_table$tumor_purity[k]) & !is.na(subset_table$tumor_purity[j]) ) {
            prim_purity <- append(prim_purity, subset_table$tumor_purity[k])
            met_purity <- append(met_purity, subset_table$tumor_purity[j])
            num_pairs <- num_pairs+1
          }
        } 
        if(Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary") {
          if(!is.na(subset_table$tumor_purity[k]) & !is.na(subset_table$tumor_purity[j])) {
            prim_purity <- append(prim_purity, subset_table$tumor_purity[j])
            met_purity <- append(met_purity, subset_table$tumor_purity[k])
            num_pairs <- num_pairs+1
          }
        }
      }
    }
  }
  
  # & subset_table$TMB[k] != "NA" & subset_table$TMB[j] != "NA"
  
  if(length(prim_purity) < 1) {next}
  cancer_plot <- cancer_type_added[d]
  # Perform Wilcoxon signed-rank test
  prim_purity <- as.numeric(prim_purity)
  met_purity <- as.numeric(met_purity)
  result <- wilcox.test(prim_purity, met_purity, paired = TRUE)
  p_value <- result$p.value
  p_value <- round(p_value, digits= 5)
  
  data <- data.frame(Primary = prim_purity, Metastasis = met_purity)
  data$Index <- seq_along(prim_purity)
  # Reshape the data frame into long format
  data_long <- reshape2::melt(data, id.vars = "Index")
  
  # Create a factor variable for the variable column with the desired order
  data_long$variable <- factor(data_long$variable, levels = c("Primary", "Metastasis"))
  
  # data_long <- gather(data, key = "Group", value = "Value", Primary, Metastasis)
  boxplot <- ggplot(data_long, aes(x = variable, y = value, fill = variable)) +
    geom_boxplot() +
    geom_line(aes(group = Index), color = "blue")+
    labs(x = "Group", y = "Tumor Purity", title = paste0("", cancer_plot, " (N = ", num_pairs, ")"), caption = paste0("p-value: ", p_value), fill = "Category") +
    theme_minimal() +
    theme(plot.caption = element_text(size = 20)) +
    theme(axis.text.x = element_text(size = 20))+
    theme(axis.text.y = element_text(size = 20)) + 
    theme(axis.title.x = element_text(size = 20))+
    theme(axis.title.y = element_text(size = 20)) +
    theme(plot.title = element_text(size = 20)) +
    theme(plot.title = element_text(size = 20))+
    theme(legend.text =element_text(size = 15)) +
    theme(legend.title = element_text(size = 15))
  
  # Add the box plot to the list
  box_plots[[d - skipped]] <- boxplot
}

figure <- cowplot::plot_grid(plotlist = box_plots, nrow = 3, ncol = 4)
png("tumorpurity.png", width = 2600, height = 1300)
figure
dev.off()
```


```{r}
# deeper dive into FGA for Colorectal Cancer
diff_dates_instable <- c()
diff_FGA_instable <- c()
diff_dates_stable <- c()
diff_FGA_stable <- c()
diff_dates_mixed <- c()
diff_FGA_mixed <- c()
diff_dates_indeterminate <- c()
diff_FGA_indeterminate <- c()
diff_dates_DNR <- c()
diff_FGA_DNR <- c()
diff_dates_other <- c()
diff_FGA_other <- c()

count_MSS <- 0
count_MSI <- 0
count_mixed <- 0
count_DNR <- 0
count_Indeterminate <- 0
count_remain <- 0

cancer_type_studied <- both_geq_async_5
num_rows <- length(cancer_type_studied)

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)
FGA <- numeric(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type_studied[i]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Dates$PATIENT_ID[patient_ID_index]
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  FGA_row_ind <- which(geq$Sample.ID == sample_ID[i])
  FGA[i] <- geq$Fraction.Genome.Altered[FGA_row_ind]
}

# create a table with 4 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired, FGA)

distinct_patients <- unique(patient_ID)
for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  
  # values in prim_sync_3 that have the same patient ID as distinct_patients[i]
  sync_version <- both_geq_sync_5
  values_in_sync <- sync_version[grep(distinct_patients[i], sync_version)]
  
  if(length(values_in_sync) > 0) {
    for (j in 1:nrow(subset_table)) {
      for(k in 1:length(values_in_sync)) {
        sample_id <- values_in_sync[k]
        patient_ID_index <- which(Dates$SAMPLE_ID == sample_id)
        date_obtained <- Dates$START_DATE[patient_ID_index]
        FGA_row_ind <- which(geqsync$Sample.ID == sample_id)
        FGA_val <- geqsync$Fraction.Genome.Altered[FGA_row_ind]
        
        async_val_index <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        sync_val_index <- which(Clinical$SAMPLE_ID == sample_id)
        
        if((Clinical$SAMPLE_TYPE[async_val_index] == "Primary" & Clinical$SAMPLE_TYPE[sync_val_index] == "Metastasis") | (Clinical$SAMPLE_TYPE[async_val_index] == "Metastasis" & Clinical$SAMPLE_TYPE[sync_val_index] == "Primary")) {
          if(!is.na(subset_table$FGA[j]) & !is.na(FGA_val) & !is.na(subset_table$date_acquired[j]) & !is.na(date_obtained)) {
            if(abs(sum(subset_table$date_acquired[j], -date_obtained) > 3650)) {
              next
            }
            if(subset_table$date_acquired[j] > date_obtained) {
              if(Clinical$MSI_TYPE[async_val_index] == "Stable" & Clinical$MSI_TYPE[sync_val_index] == "Stable") {
                diff_dates_stable <- append(diff_dates_stable, sum(subset_table$date_acquired[j], -date_obtained))
                diff_FGA_stable <- append(diff_FGA_stable, sum(subset_table$FGA[j], -FGA_val))
                count_MSS <- count_MSS+1
              }
              else if(Clinical$MSI_TYPE[async_val_index] == "Do not report" | Clinical$MSI_TYPE[sync_val_index] == "Do not report") {
                diff_dates_DNR <- append(diff_dates_DNR, sum(subset_table$date_acquired[j], -date_obtained))
                diff_FGA_DNR <- append(diff_FGA_DNR, sum(subset_table$FGA[j], -FGA_val))
                count_DNR <- count_DNR+1
              }
              else if(Clinical$MSI_TYPE[async_val_index] == "Indeterminate" | Clinical$MSI_TYPE[sync_val_index] == "Indeterminate") {
                diff_dates_indeterminate <- append(diff_dates_indeterminate, sum(subset_table$date_acquired[j], -date_obtained))
                diff_FGA_indeterminate <- append(diff_FGA_indeterminate, sum(subset_table$FGA[j], -FGA_val))
                count_Indeterminate <- count_Indeterminate+1
              }
            }
            else {
              if(Clinical$MSI_TYPE[async_val_index] == "Stable" & Clinical$MSI_TYPE[sync_val_index] == "Stable") {
                diff_dates_stable <- append(diff_dates_stable, sum(-subset_table$date_acquired[j], date_obtained))
                diff_FGA_stable <- append(diff_FGA_stable, sum(-subset_table$FGA[j], FGA_val))
                count_MSS <- count_MSS+1
              }
              else if(Clinical$MSI_TYPE[async_val_index] == "Do not report" | Clinical$MSI_TYPE[sync_val_index] == "Do not report") {
                diff_dates_DNR <- append(diff_dates_DNR, sum(-subset_table$date_acquired[j], date_obtained))
                diff_FGA_DNR <- append(diff_FGA_DNR, sum(-subset_table$FGA[j], FGA_val))
                count_DNR <- count_DNR+1
              }
              else if(Clinical$MSI_TYPE[async_val_index] == "Indeterminate" | Clinical$MSI_TYPE[sync_val_index] == "Indeterminate") {
                diff_dates_indeterminate <- append(diff_dates_indeterminate, sum(-subset_table$date_acquired[j], date_obtained))
                diff_FGA_indeterminate <- append(diff_FGA_indeterminate, sum(-subset_table$FGA[j], FGA_val))
                count_Indeterminate <- count_Indeterminate+1
              }
            }
          }
        }
      }
    }
  }
  
  if(nrow(subset_table) == 1) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):nrow(subset_table)) {
      row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
      row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
      if((Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") | (Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary")) {
        if(!is.na(sum(subset_table$FGA[k], -subset_table$FGA[j]))) {
          if(sum(subset_table$date_acquired[k], -subset_table$date_acquired[j]) > 3650) {
            next
          }
          if(Clinical$MSI_TYPE[row_ind_k] == "Stable" & Clinical$MSI_TYPE[row_ind_j] == "Stable") {
            diff_dates_stable <- append(diff_dates_stable, sum(subset_table$date_acquired[k], -subset_table$date_acquired[j]))
            diff_FGA_stable <- append(diff_FGA_stable, sum(subset_table$FGA[k], -subset_table$FGA[j]))
            count_MSS <- count_MSS+1
          }
          # else if(Clinical$MSI_TYPE[row_ind_k] == "Instable" & Clinical$MSI_TYPE[row_ind_j] == "Instable") {
          #   diff_dates_instable <- append(diff_dates_instable, abs(sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])))
          #   diff_FGA_instable <- append(diff_FGA_instable, sum(subset_table$FGA[k], -subset_table$FGA[j]))
          #   count_MSI <- count_MSI+1
          # }
          # else if((Clinical$MSI_TYPE[row_ind_k] == "Instable" & Clinical$MSI_TYPE[row_ind_j] == "Stable") | (Clinical$MSI_TYPE[row_ind_k] == "Stable" & Clinical$MSI_TYPE[row_ind_j] == "Instable")){
          #   diff_dates_mixed <- append(diff_dates_mixed, abs(sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])))
          #   diff_FGA_mixed <- append(diff_FGA_mixed, sum(subset_table$FGA[k], -subset_table$FGA[j]))
          #   count_mixed <- count_mixed+1
          # }
          else if(Clinical$MSI_TYPE[row_ind_k] == "Do not report" | Clinical$MSI_TYPE[row_ind_j] == "Do not report") {
            diff_dates_DNR <- append(diff_dates_DNR, sum(subset_table$date_acquired[k], -subset_table$date_acquired[j]))
            diff_FGA_DNR <- append(diff_FGA_DNR, sum(subset_table$FGA[k], -subset_table$FGA[j]))
            count_DNR <- count_DNR+1
          }
          else if(Clinical$MSI_TYPE[row_ind_k] == "Indeterminate" | Clinical$MSI_TYPE[row_ind_j] == "Indeterminate") {
            diff_dates_indeterminate <- append(diff_dates_indeterminate, sum(subset_table$date_acquired[k], -subset_table$date_acquired[j]))
            diff_FGA_indeterminate <- append(diff_FGA_indeterminate, sum(subset_table$FGA[k], -subset_table$FGA[j]))
            count_Indeterminate <- count_Indeterminate+1
          }
          # else {
          #   diff_dates_other <- append(diff_dates_other, abs(sum(subset_table$date_acquired[k], -subset_table$date_acquired[j])))
          #   diff_FGA_other <- append(diff_FGA_other, sum(subset_table$FGA[k], -subset_table$FGA[j]))
          #   count_remain <- count_remain+1
          # }
        }
      }
    }
  }
}
# print(count_MSS)
# print(count_MSI)
# print(count_mixed)
# print(count_DNR)
# print(count_Indeterminate)
# print(count_remain)

spearman_coef <- cor.test(diff_dates_indeterminate, diff_FGA_indeterminate, method = "spearman")
p_value <- spearman_coef$p.value

# data_instable <- data.frame(x = diff_dates_instable, y = diff_FGA_instable)
data_stable <- data.frame(x = diff_dates_stable, y = diff_FGA_stable)
data_indeterminate <- data.frame(x = diff_dates_indeterminate, y = diff_FGA_indeterminate)
data_DNR <- data.frame(x = diff_dates_DNR, y = diff_FGA_DNR)
# data_other <- data.frame(x = diff_dates_other, y = diff_FGA_other)
# data_mixed <- data.frame(x = diff_dates_mixed, y = diff_FGA_mixed)

plot <- ggplot() +
  # geom_point(data = data_instable, aes(x = x, y = y, color = "Instable"), size = 3) +
  # geom_smooth(data = data_instable, aes(x = x, y = y), color = "purple", method = "lm", se = FALSE) +
  geom_point(data = data_stable, aes(x = x, y = y, color = "Stable"), size = 3) +
  geom_smooth(data = data_stable, aes(x = x, y = y), color = "red", method = "lm", se = FALSE) +
  geom_point(data = data_indeterminate, aes(x = x, y = y, color = "Indeterminate"), size = 3) +
  geom_smooth(data = data_indeterminate, aes(x = x, y = y), color = "orange", method = "lm", se = FALSE) +
  geom_point(data = data_DNR, aes(x = x, y = y, color = "Do not report"), size = 3) +
  geom_smooth(data = data_DNR, aes(x = x, y = y), color = "blue", method = "lm", se = FALSE) +
  # geom_point(data = data_other, aes(x = x, y = y, color = "NA"), size = 3) +
  # geom_smooth(data = data_other, aes(x = x, y = y), color = "green", method = "lm", se = FALSE) +
  # geom_point(data = data_mixed, aes(x = x, y = y, color = "Mixed"), size = 3) +
  # geom_smooth(data = data_mixed, aes(x = x, y = y), color = "brown", method = "lm", se = FALSE) +
  labs(title = "Difference in Colorectal Cancer FGA vs. Difference in days of sample acquisition", x = "difference in days in sample acquisition", y = "difference in fraction of genome altered", caption = paste0("Indeterminate p-value: ", p_value)) +
  theme_minimal() +
  theme(plot.caption = element_text(size = 40)) +
  theme(axis.text.x = element_text(size = 40))+
  theme(axis.text.y = element_text(size = 40)) + 
  theme(axis.title.x = element_text(size = 40))+
  theme(axis.title.y = element_text(size = 40)) +
  theme(legend.text =element_text(size = 40)) +
  theme(title = element_text(size = 40)) +
  
  scale_color_manual(values = c("Stable" = "red", "Indeterminate" = "orange", "Do not report" = "blue"),
                  labels = c("Do not report", "Indeterminate", "Stable"), guide = guide_legend(title = "Category"))

png("colorectal.png", width = 2700, height = 1300)
plot
dev.off()
# "Mixed" = "brown", , "Other" = "green"
```

```{r}
MAF <- read.csv('MAF.csv')
CNA <- read.csv('CNA.csv')
Fusions <- read.csv('SV.csv')

# all oncogenic mutations GAM is oncogenic_tab

oncogenic_fusions <- Fusions %>% filter(str_detect(ONCOGENIC, "Oncogenic"))
oncogenic_fusions_first <- oncogenic_fusions[,c("Tumor_Sample_Barcode", "Site1_Hugo_Symbol", "Site2_Hugo_Symbol")]
# Create a new data frame to store the modified data
oncogenic_fusions_s <- data.frame(
  Tumor_Sample_Barcode = c(),
  Hugo_Symbol = c()
)

# Iterate over the rows of the original data frame
for (i in 1:nrow(oncogenic_fusions_first)) {
  # Check if Site2_Hugo_Symbol is not empty
  if (!is.na(oncogenic_fusions_first[i, "Site2_Hugo_Symbol"])) {
    # Append the corresponding rows to the modified data frame
    oncogenic_fusions_s <- rbind(
      oncogenic_fusions_s,
      data.frame(
        Tumor_Sample_Barcode = oncogenic_fusions_first[i, "Tumor_Sample_Barcode"],
        Hugo_Symbol = oncogenic_fusions_first[i, "Site2_Hugo_Symbol"]
      )
    )
  }
}

oncogenic_CNA <- CNA %>% filter(str_detect(ONCOGENIC, "Oncogenic"))
oncogenic_CNA_s <- oncogenic_CNA[,c("Tumor_Sample_Barcode", "Hugo_Symbol")]

oncogenic_MAF <- MAF %>% filter(str_detect(ONCOGENIC, "Oncogenic"))
oncogenic_MAF_s <- oncogenic_MAF[,c("Tumor_Sample_Barcode", "Hugo_Symbol")]

oncogenic <- rbind(oncogenic_MAF_s, oncogenic_CNA_s, oncogenic_fusions_s)

concatenated_prim <- unlist(prim)
concatenated_met <- unlist(met)
concatenated_both <- unlist(both)

all_samples_studied <- unique(c(concatenated_prim, concatenated_met, concatenated_both))

all_samples <- unique(oncogenic$Tumor_Sample_Barcode)
distinct_samples <- c()
for (i in 1:length(all_samples_studied)) {
  if(all_samples_studied[i] %in% all_samples) {
    distinct_samples <- append(distinct_samples, all_samples_studied[i])
  }
}

distinct_all_genes = unique(oncogenic$Hugo_Symbol)
all_genes <- read.delim('impact_genes_upto505.txt', header = TRUE, sep = "\t")
distinct_genes <- c()
for(i in 1:length(distinct_all_genes)) {
  gene_index <- which(all_genes$Approved.Symbol == distinct_all_genes[i])
  if(length(gene_index) > 0) {
    if(all_genes$First.Design[gene_index] == "IMPACT-341") {
      distinct_genes <- append(distinct_genes, distinct_all_genes[i])
    }
  }
}

oncogenic_tab <- matrix(nrow = length(distinct_genes), ncol = length(distinct_samples))
colnames(oncogenic_tab) <- distinct_samples
rownames(oncogenic_tab) <- distinct_genes

# Initialize all values to 0
oncogenic_tab[] <- 0

for (i in 1:length(distinct_samples)) {
  row_ind <- which(oncogenic$Tumor_Sample_Barcode == distinct_samples[i])
  if(length(row_ind) == 1) {
    gene_id = oncogenic$Hugo_Symbol[row_ind]
    column_index <- which(colnames(oncogenic_tab) == distinct_samples[i])
    row_index <- which(rownames(oncogenic_tab) == gene_id)
    if(length(row_index) > 0) { oncogenic_tab[row_index, column_index] = 1     }
  }
  if(length(row_ind) > 1) {
    for(j in row_ind){
      gene_id = oncogenic$Hugo_Symbol[j]
      column_index <- which(colnames(oncogenic_tab) == distinct_samples[i])
      row_index <- which(rownames(oncogenic_tab) == gene_id)
      if(length(row_index) > 0) { oncogenic_tab[row_index, column_index] = 1 }
    }
  }
}
zero_columns <- which(colSums(oncogenic_tab == 0) == nrow(oncogenic_tab))
oncogenic_tab <- oncogenic_tab[, -zero_columns]
oncogenic_tab <- oncogenic_tab[, colSums(oncogenic_tab) > 0]
# write.csv(oncogenic_tab, file = 'oncogenic.csv')
```


```{r}
# all mutations GAM is mut_tab
fusions_first <- Fusions[,c("Tumor_Sample_Barcode", "Site1_Hugo_Symbol", "Site2_Hugo_Symbol")]
# Create a new data frame to store the modified data
fusions_s <- data.frame(
  Tumor_Sample_Barcode = c(),
  Hugo_Symbol = c()
)

# Iterate over the rows of the original data frame
for (i in 1:nrow(fusions_first)) {
  # Check if Site2_Hugo_Symbol is not empty
  if (!is.na(fusions_first[i, "Site2_Hugo_Symbol"])) {
    # Append the corresponding rows to the modified data frame
    fusions_s <- rbind(
      fusions_s,
      data.frame(
        Tumor_Sample_Barcode = fusions_first[i, "Tumor_Sample_Barcode"],
        Hugo_Symbol = fusions_first[i, "Site2_Hugo_Symbol"]
      )
    )
  }
}

CNA_s <- CNA[,c("Tumor_Sample_Barcode", "Hugo_Symbol")]

MAF_s <- MAF[,c("Tumor_Sample_Barcode", "Hugo_Symbol")]

mutations <- rbind(MAF_s, CNA_s, fusions_s)

concatenated_prim <- unlist(prim)
concatenated_met <- unlist(met)
concatenated_both <- unlist(both)

distinct_samples <- unique(c(concatenated_prim, concatenated_met, concatenated_both))

distinct_all_genes = unique(mutations$Hugo_Symbol)
all_genes <- read.delim('impact_genes_upto505.txt', header = TRUE, sep = "\t")
distinct_genes <- c()
for(i in 1:length(distinct_all_genes)) {
  gene_index <- which(all_genes$Approved.Symbol == distinct_all_genes[i])
  if(length(gene_index) > 0) {
    if(all_genes$First.Design[gene_index] == "IMPACT-341") {
      distinct_genes <- append(distinct_genes, distinct_all_genes[i])
    }
  }
}

mut_tab <- matrix(nrow = length(distinct_genes), ncol = length(distinct_samples))
colnames(mut_tab) <- distinct_samples
rownames(mut_tab) <- distinct_genes

# Initialize all values to 0
mut_tab[] <- 0

for (i in 1:length(distinct_samples)) {
  row_ind <- which(mutations$Tumor_Sample_Barcode == distinct_samples[i])
  if(length(row_ind) == 1) {
    gene_id = mutations$Hugo_Symbol[row_ind]
    column_index <- which(colnames(mut_tab) == distinct_samples[i])
    row_index <- which(rownames(mut_tab) == gene_id)
    if(length(row_index) > 0) { mut_tab[row_index, column_index] = 1     }
  }
  if(length(row_ind) > 1) {
    for(j in row_ind){
      gene_id = mutations$Hugo_Symbol[j]
      column_index <- which(colnames(mut_tab) == distinct_samples[i])
      row_index <- which(rownames(mut_tab) == gene_id)
      if(length(row_index) > 0) { mut_tab[row_index, column_index] = 1 }
    }
  }
}

# write.csv(mut_tab, file = 'muttab.csv')
```

```{r}
# Jaccard index for pairs of both
box_plots <- list()
samples <- c()

skipped <- 0
for(d in 1:length(cancer_type_added)) {
  num_pairs_sync <- 0
  num_pairs_async <- 0
  if(d %in% excluded) {
    skipped <- skipped + 1
    next
  }
  
  cancer_type_studied <- unique(both[[d]])
  
  mut_sync_Jaccard <- c()
  oncogenic_sync_Jaccard <- c()
  
  mut_async_Jaccard <- c()
  oncogenic_async_Jaccard <- c()

  num_rows <- length(cancer_type_studied)
  if(num_rows < 1) {next}

  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  date_acquired <- integer(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- cancer_type_studied[i]
    clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  }
  
  # create a table with 3 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, date_acquired)
  distinct_patients <- unique(patient_ID)
  
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    if(nrow(subset_table) == 1) {
      next
    }
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):(nrow(subset_table))) {
        time_difference <- subset_table$date_acquired[k] - subset_table$date_acquired[j]
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        if((Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") | (Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary")) {
          if(time_difference < SYNC_MARK) {
            oncogenic_union_count <- 0
            mut_union_count <- 0
            sample_one <- subset_table$sample_ID[j]
            sample_two <- subset_table$sample_ID[k]
            
            oncogenic_union_count <- 0
            mut_union_count <- 0
            # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
            # common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
            # mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
            
            # Compute the counts now for oncogenic mutations
            if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
              common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
              oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
            }
            
            # Compute the Jaccard Index and append to vector, validate by ensuring atleast 1 shared mutation
            # if(common_mut_count > 0) {
            #   mut_sync_Jaccard <- append(mut_sync_Jaccard, common_mut_count / mut_union_count)
            # }
            if(common_oncogenic_count > 0){
              oncogenic_sync_Jaccard <- append(oncogenic_sync_Jaccard, common_oncogenic_count / oncogenic_union_count)
              num_pairs_sync <- num_pairs_sync + 1
            }
          }
          if (time_difference > ASYNC_MARK && time_difference < ASYNC_MAX_DIFF) {
            oncogenic_union_count <- 0
            mut_union_count <- 0
            row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
            row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
            sample_one <- subset_table$sample_ID[j]
            sample_two <- subset_table$sample_ID[k]
            
            oncogenic_union_count <- 0
            mut_union_count <- 0
            # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
            # common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
            # mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
            
            # Compute the counts now for oncogenic mutations
            if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
              common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
              oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
            }
            
            # Compute the Jaccard Index and append to vector, validate by ensuring atleast 1 shared mutation
            # if(common_mut_count > 0) {
            #   mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
            # }
            if(common_oncogenic_count > 0){
              oncogenic_async_Jaccard <- append(oncogenic_async_Jaccard, common_oncogenic_count / oncogenic_union_count)
              num_pairs_async <- num_pairs_async + 1
            }
          }
          
        }
      }
    }
  }
  
  if((length(oncogenic_sync_Jaccard) < 2) | (length(oncogenic_async_Jaccard) < 2) ) {
    next
  }
  
  # Perform Wilcoxon signed-rank test
  result <- wilcox.test(oncogenic_sync_Jaccard, oncogenic_async_Jaccard, paired = FALSE)
  p_value <- result$p.value
  p_value <- p_value * 10
  p_value <- round(p_value, digits = 2)
  if (p_value < 0.01) {
    p_value = "<0.01"
  }
  if (p_value > 0.05) {
    p_value = "n.s."
  }
  
  cancer_plot <- cancer_type_added[d]

  # Combine the vectors into a data frame
  data <- data.frame(Category = factor(rep(c(paste0("Synchronous (n=", num_pairs_sync, ")"), paste0("Asynchronous (n=", num_pairs_async, ")")),
                                  times = c(length(oncogenic_sync_Jaccard), length(oncogenic_async_Jaccard))),
                                  levels = c(paste0("Synchronous (n=", num_pairs_sync, ")"), paste0("Asynchronous (n=", num_pairs_async, ")"))),
                   Jaccard = c(oncogenic_sync_Jaccard, oncogenic_async_Jaccard))

  # Create the boxplot using ggplot2
  boxplot <- ggplot(data, aes(x = Category, y = Jaccard, fill = Category)) +
    geom_boxplot() +
    labs(caption = paste0("p-value: ", p_value), x = "Category", y = "Jaccard Index", title = paste0("", cancer_plot
                                          # , " (# Sync Pairs: ", num_pairs_sync, " # Async Pairs: ", num_pairs_async, ")"
                                          )) +
    scale_fill_manual(values = c("blue", "red")) +
    theme_bw() +
    theme(plot.caption = element_text(size = 20)) +
    theme(axis.text.x = element_text(size = 13))+
    theme(axis.text.y = element_text(size = 20)) + 
    theme(axis.title.x = element_text(size = 20))+
    theme(axis.title.y = element_text(size = 20)) +
    theme(plot.title = element_text(size = 20)) +
    theme(plot.title = element_text(size = 20))+
    theme(legend.position = "none") +
    theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot
    # theme(legend.text =element_text(size = 15)) +
    # theme(legend.title = element_text(size = 15))
  
  # Add the box plot to the list
  box_plots[[d - skipped]] <- boxplot
}
figure <- cowplot::plot_grid(plotlist = box_plots, nrow = 3, ncol = 4)
# png("Jaccardprimallmutations.png", width = 2600, height = 1350)
figure
```

```{r}
# Pairs of both primary and met singular plot
num_pairs_sync <- 0
num_pairs_async <- 0
if(d %in% excluded) {
  skipped <- skipped + 1
  next
}

cancer_type_studied <- unique(both[[DUCTAL]])

mut_sync_Jaccard <- c()
oncogenic_sync_Jaccard <- c()

mut_async_Jaccard <- c()
oncogenic_async_Jaccard <- c()

num_rows <- length(cancer_type_studied)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type_studied[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired)
distinct_patients <- unique(patient_ID)

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  if(nrow(subset_table) == 1) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      time_difference <- subset_table$date_acquired[k] - subset_table$date_acquired[j]
      row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
      row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
      if((Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") | (Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary")) {
        if(time_difference < SYNC_MARK) {
          oncogenic_union_count <- 0
          mut_union_count <- 0
          sample_one <- subset_table$sample_ID[j]
          sample_two <- subset_table$sample_ID[k]
          
          oncogenic_union_count <- 0
          mut_union_count <- 0
          # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
          # common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
          # mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
          
          # Compute the counts now for oncogenic mutations
          if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
            common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
            oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
          }
          
          # Compute the Jaccard Index and append to vector, validate by ensuring atleast 1 shared mutation
          # if(common_mut_count > 0) {
          #   mut_sync_Jaccard <- append(mut_sync_Jaccard, common_mut_count / mut_union_count)
          # }
          if(common_oncogenic_count > 0){
            oncogenic_sync_Jaccard <- append(oncogenic_sync_Jaccard, common_oncogenic_count / oncogenic_union_count)
            num_pairs_sync <- num_pairs_sync + 1
          }
        }
        if (time_difference > ASYNC_MARK && time_difference < ASYNC_MAX_DIFF) {
          oncogenic_union_count <- 0
          mut_union_count <- 0
          row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
          row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
          sample_one <- subset_table$sample_ID[j]
          sample_two <- subset_table$sample_ID[k]
          
          oncogenic_union_count <- 0
          mut_union_count <- 0
          # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
          # common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
          # mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
          
          # Compute the counts now for oncogenic mutations
          if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
            common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
            oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
          }
          
          # Compute the Jaccard Index and append to vector, validate by ensuring atleast 1 shared mutation
          # if(common_mut_count > 0) {
          #   mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
          # }
          if(common_oncogenic_count > 0){
            oncogenic_async_Jaccard <- append(oncogenic_async_Jaccard, common_oncogenic_count / oncogenic_union_count)
            num_pairs_async <- num_pairs_async + 1
          }
        }
        
      }
    }
  }
}

if((length(oncogenic_sync_Jaccard) < 2) | (length(oncogenic_async_Jaccard) < 2) ) {
  next
}

# Perform Wilcoxon signed-rank test
result <- wilcox.test(oncogenic_sync_Jaccard, oncogenic_async_Jaccard, paired = FALSE)
p_value <- result$p.value
p_value <- p_value * 10
p_value <- round(p_value, digits = 2)
if (p_value < 0.01) {
  p_value = "<0.01"
}
if (p_value > 0.05) {
  p_value = "n.s."
}

cancer_plot <- cancer_type_added[d]

# Combine the vectors into a data frame
data <- data.frame(Category = factor(rep(c(paste0("Synchronous (n=", num_pairs_sync, ")"), paste0("Asynchronous (n=", num_pairs_async, ")")),
                                         times = c(length(oncogenic_sync_Jaccard), length(oncogenic_async_Jaccard))),
                                     levels = c(paste0("Synchronous (n=", num_pairs_sync, ")"), paste0("Asynchronous (n=", num_pairs_async, ")"))),
                   Jaccard = c(oncogenic_sync_Jaccard, oncogenic_async_Jaccard))

# Create the boxplot using ggplot2
boxplot <- ggplot(data, aes(x = Category, y = Jaccard, fill = Category)) +
  geom_boxplot() +
  labs(
    # caption = paste0("p-value: ", p_value),
    x = "Category", y = "Jaccard Index", title = paste0("", cancer_plot
                                                        # , " (# Sync Pairs: ", num_pairs_sync, " # Async Pairs: ", num_pairs_async, ")"
  )) +
  scale_fill_manual(values = c("blue", "red")) +
  theme_bw() +
  theme(plot.caption = element_text(size = 20)) +
  theme(axis.text.x = element_text(size = 50))+
  theme(axis.text.y = element_text(size = 50)) + 
  theme(axis.title.x = element_text(size = 40))+
  theme(axis.title.y = element_text(size = 60)) +
  theme(plot.title = element_text(size = 40)) +
  theme(plot.title = element_text(size = 40))+
  theme(legend.position = "none") +
  theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot
# theme(legend.text =element_text(size = 15)) +
# theme(legend.title = element_text(size = 15))

# figure <- cowplot::plot_grid(plotlist = box_plots, nrow = 3, ncol = 4)
# png("Jaccardprimallmutations.png", width = 2600, height = 1350)
boxplot
```


```{r}
# Jaccard index for prim and met only
box_plots <- list()
samples <- c()

skipped <- 0
for(d in 1:length(cancer_type_added)) {
  num_pairs_sync <- 0
  num_pairs_async <- 0
  if(d %in% excluded) {
    skipped <- skipped + 1
    next
  }
  
  cancer_type_studied <- unique(met[[d]])
  
  mut_sync_Jaccard <- c()
  oncogenic_sync_Jaccard <- c()
  
  mut_async_Jaccard <- c()
  oncogenic_async_Jaccard <- c()

  num_rows <- length(cancer_type_studied)
  if(num_rows < 1) {next}

  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  date_acquired <- integer(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- cancer_type_studied[i]
    clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  }
  
  # create a table with 3 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, date_acquired)
  distinct_patients <- unique(patient_ID)
  
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    if(nrow(subset_table) == 1) {
      next
    }
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):(nrow(subset_table))) {
        time_difference <- subset_table$date_acquired[k] - subset_table$date_acquired[j]
        if(time_difference < SYNC_MARK) {
          oncogenic_union_count <- 0
          mut_union_count <- 0
          row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
          row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
          sample_one <- subset_table$sample_ID[j]
          sample_two <- subset_table$sample_ID[k]
          
          oncogenic_union_count <- 0
          mut_union_count <- 0
          # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
          common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
          mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
          
          # Compute the counts now for oncogenic mutations
          if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
            common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
            oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
          }
          
          # Compute the Jaccard Index and append to vector, validate by ensuring atleast 1 shared mutation
          if(common_mut_count > 0) {
            mut_sync_Jaccard <- append(mut_sync_Jaccard, common_mut_count / mut_union_count)
          }
          if(oncogenic_union_count > 0){
            oncogenic_sync_Jaccard <- append(oncogenic_sync_Jaccard, common_oncogenic_count / oncogenic_union_count)
            num_pairs_sync <- num_pairs_sync + 1
          }
        }
        if (time_difference > ASYNC_MARK && time_difference < ASYNC_MAX_DIFF) {
          oncogenic_union_count <- 0
          mut_union_count <- 0
          row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
          row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
          sample_one <- subset_table$sample_ID[j]
          sample_two <- subset_table$sample_ID[k]
          
          oncogenic_union_count <- 0
          mut_union_count <- 0
          # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
          common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
          mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
          
          # Compute the counts now for oncogenic mutations
          if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
            common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
            oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
          }
      
          # Compute the Jaccard Index and append to vector, validate by ensuring atleast 1 shared mutation
          if(common_mut_count > 0) {
            mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
          }
          if(oncogenic_union_count > 0){
            oncogenic_async_Jaccard <- append(oncogenic_async_Jaccard, common_oncogenic_count / oncogenic_union_count)
            num_pairs_async <- num_pairs_async + 1
          }
        }
      }
    }
  }
  
  if((length(oncogenic_sync_Jaccard) < 2) | (length(oncogenic_async_Jaccard) < 2) ) {
    next
  }
  
  # Perform Wilcoxon signed-rank test
  result <- wilcox.test(oncogenic_sync_Jaccard, oncogenic_async_Jaccard, paired = FALSE)
  p_value <- result$p.value
  p_value <- p_value * 10
  p_value <- round(p_value, digits = 2)
  if (p_value < 0.01) {
    p_value = "<0.01"
  }
  if (p_value > 0.05) {
    p_value = "n.s."
  }
  
  cancer_plot <- cancer_type_added[d]

  # Combine the vectors into a data frame
  data <- data.frame(Category = factor(rep(c(paste0("Synchronous (n=", num_pairs_sync, ")"), paste0("Asynchronous (n=", num_pairs_async, ")")),
                                  times = c(length(oncogenic_sync_Jaccard), length(oncogenic_async_Jaccard))),
                                  levels = c(paste0("Synchronous (n=", num_pairs_sync, ")"), paste0("Asynchronous (n=", num_pairs_async, ")"))),
                   Jaccard = c(oncogenic_sync_Jaccard, oncogenic_async_Jaccard))

  # Create the boxplot using ggplot2
  boxplot <- ggplot(data, aes(x = Category, y = Jaccard, fill = Category)) +
    geom_boxplot() +
    labs(caption = paste0("p-value: ", p_value), x = "Category", y = "Jaccard Index", title = paste0("", cancer_plot
                                          # , " (# Sync Pairs: ", num_pairs_sync, " # Async Pairs: ", num_pairs_async, ")"
                                          )) +
    scale_fill_manual(values = c("blue", "red")) +
    theme_bw() +
    theme(plot.caption = element_text(size = 20)) +
    theme(axis.text.x = element_text(size = 13))+
    theme(axis.text.y = element_text(size = 20)) + 
    theme(axis.title.x = element_text(size = 20))+
    theme(axis.title.y = element_text(size = 20)) +
    theme(plot.title = element_text(size = 20)) +
    theme(plot.title = element_text(size = 20))+
    theme(legend.position = "none") +
    theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot
    # theme(legend.text =element_text(size = 15)) +
    # theme(legend.title = element_text(size = 15))
    
  # Add the box plot to the list
  box_plots[[d - skipped]] <- boxplot
}
figure <- cowplot::plot_grid(plotlist = box_plots, nrow = 3, ncol = 4)
# png("Jaccardprimallmutations.png", width = 2600, height = 1350)
figure
# dev.off()
```

```{r}
# singular version of Jaccard prim or met
num_pairs_sync <- 0
num_pairs_async <- 0

cancer_type_studied <- unique(prim[[LUAD]])

mut_sync_Jaccard <- c()
oncogenic_sync_Jaccard <- c()

mut_async_Jaccard <- c()
oncogenic_async_Jaccard <- c()

num_rows <- length(cancer_type_studied)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type_studied[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired)
distinct_patients <- unique(patient_ID)

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  if(nrow(subset_table) == 1) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      time_difference <- subset_table$date_acquired[k] - subset_table$date_acquired[j]
      if(time_difference < SYNC_MARK) {
        oncogenic_union_count <- 0
        mut_union_count <- 0
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        sample_one <- subset_table$sample_ID[j]
        sample_two <- subset_table$sample_ID[k]
        
        oncogenic_union_count <- 0
        mut_union_count <- 0
        # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
        common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
        mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
        
        # Compute the counts now for oncogenic mutations
        if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
          common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
          oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
        }
        
        # Compute the Jaccard Index and append to vector
        if(mut_union_count > 0) {
          mut_sync_Jaccard <- append(mut_sync_Jaccard, common_mut_count / mut_union_count)
        }
        if(common_oncogenic_count > 0){
          oncogenic_sync_Jaccard <- append(oncogenic_sync_Jaccard, common_oncogenic_count / oncogenic_union_count)
          num_pairs_sync <- num_pairs_sync + 1
        }
      }
      if (time_difference > ASYNC_MARK && time_difference < ASYNC_MAX_DIFF) {
        oncogenic_union_count <- 0
        mut_union_count <- 0
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        sample_one <- subset_table$sample_ID[j]
        sample_two <- subset_table$sample_ID[k]
        
        oncogenic_union_count <- 0
        mut_union_count <- 0
        # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
        common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
        mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
        
        # Compute the counts now for oncogenic mutations
        if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
          common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
          oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
        }
        
        # Compute the Jaccard Index and append to vector
        if(mut_union_count > 0) {
          mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
        }
        if(common_oncogenic_count > 0){
          oncogenic_async_Jaccard <- append(oncogenic_async_Jaccard, common_oncogenic_count / oncogenic_union_count)
          num_pairs_async <- num_pairs_async + 1
        }
      }
    }
  }
}

if((length(oncogenic_sync_Jaccard) < 2) || (length(oncogenic_async_Jaccard) < 2) ) {
  next
}

# Perform Wilcoxon signed-rank test
result <- wilcox.test(oncogenic_sync_Jaccard, oncogenic_async_Jaccard, paired = FALSE)
p_value <- result$p.value
p_value <- p_value * 10
p_value <- round(p_value, digits = 2)
if (p_value < 0.01) {
  p_value = "<0.01"
}
if (p_value > 0.05) {
  p_value = "n.s."
}

cancer_plot <- cancer_type_added[LUAD]

# Combine the vectors into a data frame
data <- data.frame(Category = factor(rep(c(paste0("Synchronous (n=", num_pairs_sync, ")"), paste0("Asynchronous (n=", num_pairs_async, ")")),
                                         times = c(length(oncogenic_sync_Jaccard), length(oncogenic_async_Jaccard))),
                                     levels = c(paste0("Synchronous (n=", num_pairs_sync, ")"), paste0("Asynchronous (n=", num_pairs_async, ")"))),
                   Jaccard = c(oncogenic_sync_Jaccard, oncogenic_async_Jaccard))

# Create the boxplot using ggplot2
boxplot <- ggplot(data, aes(x = Category, y = Jaccard, fill = Category)) +
  geom_boxplot() +
  labs(
    # caption = paste0("p-value: ", p_value),
    x = "Category", y = "Jaccard Index", title = paste0("", cancer_plot
                                                        # , " (# Sync Pairs: ", num_pairs_sync, " # Async Pairs: ", num_pairs_async, ")"
  )) +
  scale_fill_manual(values = c("blue", "red")) +
  theme_bw() +
  theme(plot.caption = element_text(size = 20)) +
  theme(axis.text.x = element_text(size = 50))+
  theme(axis.text.y = element_text(size = 50)) + 
  theme(axis.title.x = element_text(size = 40))+
  theme(axis.title.y = element_text(size = 60)) +
  theme(plot.title = element_text(size = 40)) +
  theme(plot.title = element_text(size = 40))+
  theme(legend.position = "none") +
  theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot
```


```{r}
# above plot for LUAD pairs of primaries stratified into 4 time groups (<=90 days, <1 yr, <2 yr, >=2 yr)
num_pairs_sync <- 0
num_pairs_1yr <- 0
num_pairs_2yr <- 0
num_pairs_over2yr <- 0

cancer_type_studied <- unique(prim[[LUAD]])

mut_sync_Jaccard <- c()
oncogenic_sync_Jaccard <- c()

mut_async_Jaccard <- c()
oncogenic_1yr_Jaccard <- c()

oncogenic_2yr_Jaccard <- c()
oncogenic_over2yr_Jaccard <- c()

num_rows <- length(cancer_type_studied)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type_studied[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired)
distinct_patients <- unique(patient_ID)

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  if(nrow(subset_table) == 1) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      time_difference <- subset_table$date_acquired[k] - subset_table$date_acquired[j]
      if(time_difference <= SYNC_MARK) {
        oncogenic_union_count <- 0
        mut_union_count <- 0
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        sample_one <- subset_table$sample_ID[j]
        sample_two <- subset_table$sample_ID[k]
        
        oncogenic_union_count <- 0
        mut_union_count <- 0
        # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
        common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
        mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
        
        # Compute the counts now for oncogenic mutations
        if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
          common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
          oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
        }
        
        # Compute the Jaccard Index and append to vector
        if(mut_union_count > 0) {
          mut_sync_Jaccard <- append(mut_sync_Jaccard, common_mut_count / mut_union_count)
        }
        if(common_oncogenic_count > 0){
          oncogenic_sync_Jaccard <- append(oncogenic_sync_Jaccard, common_oncogenic_count / oncogenic_union_count)
          num_pairs_sync <- num_pairs_sync + 1
        }
      }
      else if (time_difference < 365) {
        oncogenic_union_count <- 0
        mut_union_count <- 0
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        sample_one <- subset_table$sample_ID[j]
        sample_two <- subset_table$sample_ID[k]
        
        oncogenic_union_count <- 0
        mut_union_count <- 0
        # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
        common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
        mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
        
        # Compute the counts now for oncogenic mutations
        if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
          common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
          oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
        }
        
        # Compute the Jaccard Index and append to vector
        if(mut_union_count > 0) {
          mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
        }
        if(common_oncogenic_count > 0){
          oncogenic_1yr_Jaccard <- append(oncogenic_1yr_Jaccard, common_oncogenic_count / oncogenic_union_count)
          num_pairs_1yr <- num_pairs_1yr + 1
        }
      }
      else if (time_difference < 730) {
        oncogenic_union_count <- 0
        mut_union_count <- 0
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        sample_one <- subset_table$sample_ID[j]
        sample_two <- subset_table$sample_ID[k]
        
        oncogenic_union_count <- 0
        mut_union_count <- 0
        # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
        common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
        mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
        
        # Compute the counts now for oncogenic mutations
        if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
          common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
          oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
        }
        
        # Compute the Jaccard Index and append to vector
        if(mut_union_count > 0) {
          mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
        }
        if(common_oncogenic_count > 0){
          oncogenic_2yr_Jaccard <- append(oncogenic_2yr_Jaccard, common_oncogenic_count / oncogenic_union_count)
          num_pairs_2yr <- num_pairs_2yr + 1
        }
      }
      else if (time_difference < ASYNC_MAX_DIFF) {
        oncogenic_union_count <- 0
        mut_union_count <- 0
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        sample_one <- subset_table$sample_ID[j]
        sample_two <- subset_table$sample_ID[k]
        
        oncogenic_union_count <- 0
        mut_union_count <- 0
        # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
        common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
        mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
        
        # Compute the counts now for oncogenic mutations
        if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
          common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
          oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
        }
        
        # Compute the Jaccard Index and append to vector
        if(mut_union_count > 0) {
          mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
        }
        if(common_oncogenic_count > 0){
          oncogenic_over2yr_Jaccard <- append(oncogenic_over2yr_Jaccard, common_oncogenic_count / oncogenic_union_count)
          num_pairs_over2yr <- num_pairs_over2yr + 1
        }
      }
    }
  }
}

# if((length(oncogenic_sync_Jaccard) < 2) || (length(oncogenic_2yr_Jaccard) < 2) || length) {
#   next
# }

# Perform Wilcoxon signed-rank test
# result <- wilcox.test(oncogenic_sync_Jaccard, oncogenic_async_Jaccard, paired = FALSE)
# p_value <- result$p.value
# p_value <- p_value * 10
# p_value <- round(p_value, digits = 2)
# if (p_value < 0.01) {
#   p_value = "<0.01"
# }
# if (p_value > 0.05) {
#   p_value = "n.s."
# }

cancer_plot <- cancer_type_added[LUAD]

# Combine the vectors into a data frame
data <- data.frame(Category = factor(rep(c(paste0("<=90 days (n=", num_pairs_sync, ")"), paste0("<1 yr (n=", num_pairs_1yr, ")"), paste0("<2 yr (n=", num_pairs_2yr, ")"), paste0(">=2 yr (n=", num_pairs_over2yr, ")")),
                                         times = c(length(oncogenic_sync_Jaccard), length(oncogenic_1yr_Jaccard), length(oncogenic_2yr_Jaccard), length(oncogenic_over2yr_Jaccard))),
                                     levels = c(paste0("<=90 days (n=", num_pairs_sync, ")"), paste0("<1 yr (n=", num_pairs_1yr, ")"), paste0("<2 yr (n=", num_pairs_2yr, ")"), paste0(">=2 yr (n=", num_pairs_over2yr, ")"))),
                   Jaccard = c(oncogenic_sync_Jaccard, oncogenic_1yr_Jaccard, oncogenic_2yr_Jaccard, oncogenic_over2yr_Jaccard))

# Create the boxplot using ggplot2
boxplot <- ggplot(data, aes(x = Category, y = Jaccard, fill = Category)) +
  geom_boxplot() +
  labs(
    # caption = paste0("p-value: ", p_value),
    x = "Category", y = "Jaccard Index", title = paste0("", cancer_plot
                                                        # , " (# Sync Pairs: ", num_pairs_sync, " # Async Pairs: ", num_pairs_async, ")"
  )) +
  scale_fill_manual(values = c("blue", "red", "pink", "orange")) +
  theme_bw() +
  theme(plot.caption = element_text(size = 20)) +
  theme(axis.text.x = element_text(size = 50))+
  theme(axis.text.y = element_text(size = 50)) + 
  theme(axis.title.x = element_text(size = 40))+
  theme(axis.title.y = element_text(size = 60)) +
  theme(plot.title = element_text(size = 40)) +
  theme(plot.title = element_text(size = 40))+
  theme(legend.position = "none") +
  theme(panel.border = element_rect(color = "black", size = 3, fill = NA))  # Add a border around the plot
```

```{r}
# find all genes that are mutated by the 15 sample pairs in question
matching_rows <- c()
samples <- unique(samples)
for (i in 1:length(samples)){
  column_index <- which(colnames(oncogenic_tab) == samples[i])
  
  # Find row names where the specified column has a value of 1
  matching_rows <- append(matching_rows, rownames(oncogenic_tab)[oncogenic_tab[, column_index] == 1])
}

# column_indices <- which(colnames(oncogenic_tab) %in% samples)
# matching_rows <- subset(oncogenic_tab, select = column_indices, subset = rowSums(subset(oncogenic_tab, select = column_indices) == 1) > 0)
# matching_rows <- rownames(matching_rows)
# 
print(unique(matching_rows))
write.csv(unique(matching_rows), file = "importantmutation.csv")
```

```{r}
# compare purity in the jaccard boxplot for LUAD in categories of sync and async
num_pairs_sync <- 0
num_pairs_async <- 0
d = 11

sync_type_studied <- get(paste0("prim_sync_", d))
async_type_studied <- get(paste0("prim_", d))

mut_sync_Jaccard <- c()
oncogenic_sync_Jaccard <- c()

mut_async_Jaccard <- c()
oncogenic_async_Jaccard <- c()

sync_pairs_first <- c()
sync_pairs_second <- c()

async_pairs_first <- c()
async_pairs_second <- c()

num_rows <- length(sync_type_studied)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- sync_type_studied[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired)
distinct_patients <- unique(patient_ID)

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  if(nrow(subset_table) == 1) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      if((subset_table$date_acquired[k] - subset_table$date_acquired[j]) > 90) {
        next
      }
      oncogenic_union_count <- 0
      mut_union_count <- 0
      row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
      row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
      sample_one <- subset_table$sample_ID[j]
      sample_two <- subset_table$sample_ID[k]
      
      if((Clinical$TUMOR_PURITY[row_ind_j] > 20) & (Clinical$TUMOR_PURITY[row_ind_k] > 20)) {
        # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
        common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
        mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
        
        # Compute the counts now for oncogenic mutations
        sample_one_index <- which(MAF$Tumor_Sample_Barcode== sample_one)
        sample_two_index <- which(MAF$Tumor_Sample_Barcode== sample_one)
        # if((grepl("Oncogenic", MAF$ONCOGENIC[sample_one_index])) & (grepl("Oncogenic", MAF$ONCOGENIC[sample_two_index]))) {
        if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
          common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
          oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
        }
        
        # Compute the Jaccard Index and append to vector
        if(mut_union_count > 0) {
          mut_sync_Jaccard <- append(mut_sync_Jaccard, common_mut_count / mut_union_count)
        }
        if(oncogenic_union_count > 0){
          oncogenic_sync_Jaccard <- append(oncogenic_sync_Jaccard, common_oncogenic_count / oncogenic_union_count)
          num_pairs_sync <- num_pairs_sync + 1
          sync_pairs_first <- append(sync_pairs_first, Clinical$TUMOR_PURITY[row_ind_j])
          sync_pairs_second <- append(sync_pairs_second, Clinical$TUMOR_PURITY[row_ind_k])
        }
      }
    }
  }
}

# repeat analysis for async
num_rows <- length(async_type_studied)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)
for (i in 1:num_rows) {
  sample_ID[i] <- async_type_studied[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired)
distinct_patients <- unique(patient_ID)

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  # values in prim_sync_3 that have the same patient ID as distinct_patients[i]
  sync_version <- get(paste0("prim_sync_", d))
  values_in_sync <- sync_version[grep(distinct_patients[i], sync_version)]
  
  if(length(values_in_sync) > 0) {
    for (j in 1:nrow(subset_table)) {
      for(k in 1:length(values_in_sync)) {
        sync_sample <- values_in_sync[k]
        patient_ID_index <- which(Dates$SAMPLE_ID == sync_sample)
        sync_date <- Dates$START_DATE[patient_ID_index]
        if(sync_date > subset_table$date_acquired[j]) {
          sample_one <- subset_table$sample_ID[j]
          sample_two <- sync_sample
        }
        else{
          sample_one <- sync_sample
          sample_two <- subset_table$sample_ID[j]
        }
        oncogenic_union_count <- 0
        mut_union_count <- 0
        row_ind_j <- which(Clinical$SAMPLE_ID == sample_one)
        row_ind_k <- which(Clinical$SAMPLE_ID == sample_two)
        
        if((Clinical$TUMOR_PURITY[row_ind_j] > 20) & (Clinical$TUMOR_PURITY[row_ind_k] > 20)) {
          # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
          common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
          mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
          
          # Compute the counts now for oncogenic mutations
          if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
            common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
            oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
          }
          
          # Compute the Jaccard Index and append to vector
          if(mut_union_count > 0) {
            mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
          }
          if(oncogenic_union_count > 0){
            oncogenic_async_Jaccard <- append(oncogenic_async_Jaccard, common_oncogenic_count / oncogenic_union_count)
            num_pairs_async <- num_pairs_async + 1
            async_pairs_first <- append(async_pairs_first, Clinical$TUMOR_PURITY[row_ind_j])
            async_pairs_second <- append(async_pairs_second, Clinical$TUMOR_PURITY[row_ind_k])
            # if((d == 11) & (common_oncogenic_count / oncogenic_union_count == 1)) {
            #   samples <- append(samples, c(sample_one, sample_two))
            # }
          }
        }
      }
    }
  }
  
  
  if(nrow(subset_table) == 1) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      sample_one <- subset_table$sample_ID[j]
      sample_two <- subset_table$sample_ID[k]
      row_ind_j <- which(Clinical$SAMPLE_ID == sample_one)
      row_ind_k <- which(Clinical$SAMPLE_ID == sample_two)
      
      if((Clinical$TUMOR_PURITY[row_ind_j] <= 20) | (Clinical$TUMOR_PURITY[row_ind_k] <= 20) | (Clinical$TUMOR_PURITY[row_ind_j] == 5)) {
        next
      }
      
      # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
      common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
      mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
      
      # Compute the Jaccard Index and append to vector
      if(mut_union_count > 0) {
        mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
      }
      oncogenic_union_count <- 0
      mut_union_count <- 0
      
      # Compute the counts now for oncogenic mutations
      if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
        common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
        oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
      }
      
      if(oncogenic_union_count > 0){
        oncogenic_async_Jaccard <- append(oncogenic_async_Jaccard, common_oncogenic_count / oncogenic_union_count)
        num_pairs_async <- num_pairs_async + 1
        # if(Clinical$TUMOR_PURITY[row_ind_j] == 5) {
        #   print(Clinical$SAMPLE_ID[row_ind_j])
        # }
        async_pairs_first <- append(async_pairs_first, Clinical$TUMOR_PURITY[row_ind_j])
        async_pairs_second <- append(async_pairs_second, Clinical$TUMOR_PURITY[row_ind_k])
      }
    }
  }
}



# create the actual boxplot using mut_sync_Jaccard and oncogenic_sync_Jaccard and async

sync_pairs_first <- as.numeric(sync_pairs_first)
sync_pairs_second <- as.numeric(sync_pairs_second)

async_pairs_first <- as.numeric(async_pairs_first)
async_pairs_second <- as.numeric(async_pairs_second)



plot_lines <- function(v1, v2, x_center, col="black", jitter_amount = 0.1) {
  # Define the slant
  slant <- 0.3

  # Add slant by shifting x-coordinates for each end of the segments
  segments(x0=rep(x_center, length(v1)), y0=v1, x1=rep(x_center + slant, length(v1)), y1=v2, col=col)

  # Generate random jitter for the points
  jitter <- jitter_amount * (runif(length(v1)) - 0.5)

  # Draw points at the start and end of each line segment with jitter
  points(x=rep(x_center, length(v1)), y=v1 + jitter, pch=19, col=col)
  points(x=rep(x_center + slant, length(v1)), y=v2 + jitter, pch=19, col=col)
}

plot(1, type="n", xlim=c(0, 3), ylim=c(min(c(sync_pairs_first, sync_pairs_second, async_pairs_first, async_pairs_second)), max(c(sync_pairs_first, sync_pairs_second, async_pairs_first, async_pairs_second))), xlab="", ylab="Tumor Purity", xaxt='n')

plot_lines(sync_pairs_first, sync_pairs_second, x_center=0.35, col="blue", jitter_amount = 4)
plot_lines(async_pairs_first, async_pairs_second, x_center=2.35, col="red", jitter_amount = 4)

mtext("Synchronous", side=1, line=2, at=0.5)
mtext("Asynchronous", side=1, line=2, at=2.5)
```

```{r}
# make a complete oncoprint for all of synchronous primaries for LUAD restricting IMPACT-341 genes
box_plots <- list()
samples <- c()

skipped <- 0
for(d in 1:length(cancer_type_added)) {
  if(d %in% excluded) {
    skipped <- skipped + 1
    next
  }
  num_pairs_sync <- 0
  num_pairs_async <- 0
  
  sync_type_studied <- get(paste0("prim_sync_", d))
  async_type_studied <- get(paste0("prim_", d))
  
  mut_sync_Jaccard <- c()
  oncogenic_sync_Jaccard <- c()
  
  mut_async_Jaccard <- c()
  oncogenic_async_Jaccard <- c()

  num_rows <- length(sync_type_studied)
  if(num_rows < 1) {next}

  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  date_acquired <- integer(num_rows)
  
  for (i in 1:num_rows) {
    sample_ID[i] <- sync_type_studied[i]
    clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  }
  
  # create a table with 3 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, date_acquired)
  distinct_patients <- unique(patient_ID)
  
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    if(nrow(subset_table) == 1) {
      next
    }
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):(nrow(subset_table))) {
        if((subset_table$date_acquired[k] - subset_table$date_acquired[j]) > 90) {
          next
        }
        oncogenic_union_count <- 0
        mut_union_count <- 0
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        sample_one <- subset_table$sample_ID[j]
        sample_two <- subset_table$sample_ID[k]
        
        if((Clinical$TUMOR_PURITY[row_ind_j] > 20) & (Clinical$TUMOR_PURITY[row_ind_k] > 20)) {
          # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
          common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
          mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
          
          # Compute the counts now for oncogenic mutations
          sample_one_index <- which(MAF$Tumor_Sample_Barcode== sample_one)
          sample_two_index <- which(MAF$Tumor_Sample_Barcode== sample_one)
          # if((grepl("Oncogenic", MAF$ONCOGENIC[sample_one_index])) & (grepl("Oncogenic", MAF$ONCOGENIC[sample_two_index]))) {
          if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
            common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
            oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
          }
          
          # Compute the Jaccard Index and append to vector
          if(mut_union_count > 0) {
            mut_sync_Jaccard <- append(mut_sync_Jaccard, common_mut_count / mut_union_count)
          }
          if(oncogenic_union_count > 0){
            oncogenic_sync_Jaccard <- append(oncogenic_sync_Jaccard, common_oncogenic_count / oncogenic_union_count)
            num_pairs_sync <- num_pairs_sync + 1
            if(d == 11) {
              samples <- append(samples, c(sample_one, sample_two))
            }
          }
        }
      }
    }
  }

  # repeat analysis for async
  num_rows <- length(async_type_studied)
  if(num_rows < 1) {next}

  # create empty vectors for each column
  sample_ID <- character(num_rows)
  patient_ID <- character(num_rows)
  date_acquired <- integer(num_rows)
  for (i in 1:num_rows) {
    sample_ID[i] <- async_type_studied[i]
    clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
    patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
    patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
    date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  }
  
  # create a table with 3 columns and length(cancer_type_studied) rows
  table <- data.frame(sample_ID, patient_ID, date_acquired)
  distinct_patients <- unique(patient_ID)
  
  for (i in 1:length(distinct_patients)) {
    subset_table <- subset(table, patient_ID == distinct_patients[i])
    subset_table <- subset_table[order(subset_table$date_acquired),]
    # values in prim_sync_3 that have the same patient ID as distinct_patients[i]
    sync_version <- get(paste0("prim_sync_", d))
    values_in_sync <- sync_version[grep(distinct_patients[i], sync_version)]
    
    if(length(values_in_sync) > 0) {
      for (j in 1:nrow(subset_table)) {
        for(k in 1:length(values_in_sync)) {
          sync_sample <- values_in_sync[k]
          patient_ID_index <- which(Dates$SAMPLE_ID == sync_sample)
          sync_date <- Dates$START_DATE[patient_ID_index]
          if(sync_date > subset_table$date_acquired[j]) {
            sample_one <- subset_table$sample_ID[j]
            sample_two <- sync_sample
          }
          else{
            sample_one <- sync_sample
            sample_two <- subset_table$sample_ID[j]
          }
          oncogenic_union_count <- 0
          mut_union_count <- 0
          row_ind_k <- which(Clinical$SAMPLE_ID == sample_two)
          row_ind_j <- which(Clinical$SAMPLE_ID == sample_one)
          
          if((Clinical$TUMOR_PURITY[row_ind_j] > 20) & (Clinical$TUMOR_PURITY[row_ind_k] > 20)) {
            # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
            common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
            mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
            
            # Compute the counts now for oncogenic mutations
            sample_one_index <- which(MAF$Tumor_Sample_Barcode== sample_one)
            sample_two_index <- which(MAF$Tumor_Sample_Barcode== sample_one)
            # if((grepl("Oncogenic", MAF$ONCOGENIC[sample_one_index])) & (grepl("Oncogenic", MAF$ONCOGENIC[sample_two_index]))) {
            if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
              common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
              oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
            }
            
            # Compute the Jaccard Index and append to vector
            if(mut_union_count > 0) {
              mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
            }
            if(oncogenic_union_count > 0){
              oncogenic_async_Jaccard <- append(oncogenic_async_Jaccard, common_oncogenic_count / oncogenic_union_count)
              num_pairs_async <- num_pairs_async + 1
              # if((d == 11) & (common_oncogenic_count / oncogenic_union_count == 1)) {
              #   samples <- append(samples, c(sample_one, sample_two))
              # }
            }
          }
        }
      }
    }
    
    
    if(nrow(subset_table) == 1) {
      next
    }
    for (j in 1:(nrow(subset_table) - 1)) {
      for (k in (j+1):(nrow(subset_table))) {
        oncogenic_union_count <- 0
        mut_union_count <- 0
        row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
        row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
        sample_one <- subset_table$sample_ID[j]
        sample_two <- subset_table$sample_ID[k]
        
        if((Clinical$TUMOR_PURITY[row_ind_j] > 20) & (Clinical$TUMOR_PURITY[row_ind_k] > 20)) {
          # Count the number of common 1s between the two samples (intersection) and calculate union too for all mutations
          common_mut_count <- sum(subset(mut_tab, select = sample_one) == 1 & subset(mut_tab, select = sample_two) == 1)
          mut_union_count <- sum(subset(mut_tab, select = sample_one) == 1 | subset(mut_tab, select = sample_two) == 1)
          
          # Compute the counts now for oncogenic mutations
          sample_one_index <- which(MAF$Tumor_Sample_Barcode== sample_one)
          sample_two_index <- which(MAF$Tumor_Sample_Barcode== sample_one)
          # if((grepl("Oncogenic", MAF$ONCOGENIC[sample_one_index])) & (grepl("Oncogenic", MAF$ONCOGENIC[sample_two_index]))) {
          if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
            common_oncogenic_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 & subset(oncogenic_tab, select = sample_two) == 1)
            oncogenic_union_count <- sum(subset(oncogenic_tab, select = sample_one) == 1 | subset(oncogenic_tab, select = sample_two) == 1)
          }
          
          
          # Compute the Jaccard Index and append to vector
          if(mut_union_count > 0) {
            mut_async_Jaccard <- append(mut_async_Jaccard, common_mut_count / mut_union_count)
          }
          if(oncogenic_union_count > 0){
            oncogenic_async_Jaccard <- append(oncogenic_async_Jaccard, common_oncogenic_count / oncogenic_union_count)
            num_pairs_async <- num_pairs_async + 1
            # if((d == 11) & (common_oncogenic_count / oncogenic_union_count == 1)) {
            #   samples <- append(samples, c(sample_one, sample_two))
            # }
          }
        }
      }
    }
  }
  
  # Perform Wilcoxon signed-rank test
  result <- wilcox.test(oncogenic_sync_Jaccard, oncogenic_async_Jaccard, paired = FALSE)
  p_value <- result$p.value
  
  # create the actual boxplot using mut_sync_Jaccard and oncogenic_sync_Jaccard and async
  cancer_plot <- cancer_type_added[d]

  # Combine the vectors into a data frame
  data <- data.frame(Category = factor(rep(c("Synchronous", "Asynchronous"),
                                  times = c(length(oncogenic_sync_Jaccard), length(oncogenic_async_Jaccard))),
                                  levels = c("Synchronous", "Asynchronous")),
                   Jaccard = c(oncogenic_sync_Jaccard, oncogenic_async_Jaccard))

  # Create the boxplot using ggplot2
  boxplot <- ggplot(data, aes(x = Category, y = Jaccard, fill = Category)) +
    geom_boxplot() +
    labs(caption = p_value, x = "Category", y = "Jaccard Index", title = paste0("", cancer_plot, " (# Sync Pairs: ", num_pairs_sync, " # Async Pairs: ", num_pairs_async, ")")) +
    scale_fill_manual(values = c("blue", "red")) +
    theme_bw() +
    theme(plot.caption = element_text(size = 14))

  # print(cancer_plot)
  # print(paste("% of 2nd sync samples having higher panel count: ", second_sync_panel_greater/ num_pairs_sync))
  # print(paste("% of 1st sync samples having higher panel count: ", first_sync_panel_greater/ num_pairs_sync))
  # 
  # print(paste("% of 2nd async samples having higher panel count: ", second_async_panel_greater/ num_pairs_async))
  # print(paste("% of 1st async samples having higher panel count: ", first_async_panel_greater/ num_pairs_async))
  
  # Add the box plot to the list
  box_plots[[d - skipped]] <- boxplot
}
figure <- cowplot::plot_grid(plotlist = box_plots, nrow = 3, ncol = 4)
print(unique(samples))
png("Jaccardprimoncogenicmutations.png", width = 2600, height = 1350)
figure
dev.off()
```

```{r}
# Manhattan distance version for only prim and mets
# box_plots <- list()
# 
# for(d in 1:16) {
#   num_pairs_sync <- 0
#   num_pairs_async <- 0
#   
#   sync_type_studied <- get(paste0("prim_sync_", d))
#   async_type_studied <- get(paste0("prim_", d))
#   
#   mut_sync_Manhattan <- c()
#   oncogenic_sync_Manhattan <- c()
#   
#   mut_async_Manhattan <- c()
#   oncogenic_async_Manhattan <- c()
# 
#   num_rows <- length(sync_type_studied)
#   if(num_rows < 1) {next}
# 
#   # create empty vectors for each column
#   sample_ID <- character(num_rows)
#   patient_ID <- character(num_rows)
#   
#   for (i in 1:num_rows) {
#     sample_ID[i] <- sync_type_studied[i]
#     clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
#     patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
#   }
#   
#   # create a table with 2 columns and length(cancer_type_studied) rows
#   table <- data.frame(sample_ID, patient_ID)
#   distinct_patients <- unique(patient_ID)
#   
#   for (i in 1:length(distinct_patients)) {
#     subset_table <- subset(table, patient_ID == distinct_patients[i])
#     if(nrow(subset_table) == 1) {
#       next
#     }
#     for (j in 1:(nrow(subset_table) - 1)) {
#       for (k in (j+1):(nrow(subset_table))) {
#         row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
#         row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
#         sample_one <- subset_table$sample_ID[j]
#         sample_two <- subset_table$sample_ID[k]
#           
#         num_pairs_sync <- num_pairs_sync + 1
#           
#         # Calculate Manhattan distance between two samples
#         sample_one_mut_vector <- as.vector(subset(mut_tab, select = sample_one))
#         sample_two_mut_vector <- as.vector(subset(mut_tab, select = sample_two))
#         
#         sample_one_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_one))
#         sample_two_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_two))
#         
#         # Calculate Manhattan distance
#         distance_mut <- dist(rbind(sample_one_mut_vector, sample_two_mut_vector), method = "manhattan")
#         distance_onc <- dist(rbind(sample_one_onc_vector, sample_two_onc_vector), method = "manhattan")
#         
#         mut_sync_Manhattan <- append(mut_sync_Manhattan, distance_mut)
#         oncogenic_sync_Manhattan <- append(oncogenic_sync_Manhattan, distance_onc)
#       }
#     }
#   }
#   
#   # if(d == 1) {
#   #   print(subset_table$sample_ID)
#   # }
#   
#   # repeat analysis for async
#   num_rows <- length(async_type_studied)
#   if(num_rows < 1) {next}
# 
#   # create empty vectors for each column
#   sample_ID <- character(num_rows)
#   patient_ID <- character(num_rows)
#   date_acquired <- integer(num_rows)
#   for (i in 1:num_rows) {
#     sample_ID[i] <- async_type_studied[i]
#     clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
#     patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
#   }
#   
#   # create a table with 3 columns and length(cancer_type_studied) rows
#   table <- data.frame(sample_ID, patient_ID)
#   distinct_patients <- unique(patient_ID)
#   
#   for (i in 1:length(distinct_patients)) {
#     subset_table <- subset(table, patient_ID == distinct_patients[i])
#     
#     # values in prim_sync_3 that have the same patient ID as distinct_patients[i]
#     sync_version <- get(paste0("prim_sync_", d))
#     values_in_sync <- sync_version[grep(distinct_patients[i], sync_version)]
#     
#     if(length(values_in_sync) > 0) {
#       for (j in 1:nrow(subset_table)) {
#         for(k in 1:length(values_in_sync)) {
#           num_pairs_async <- num_pairs_async + 1
#           sample_one <- values_in_sync[k]
#           sample_two <- subset_table$sample_ID[j]
#           
#           # Calculate Manhattan distance between two samples
#           sample_one_mut_vector <- as.vector(subset(mut_tab, select = sample_one))
#           sample_two_mut_vector <- as.vector(subset(mut_tab, select = sample_two))
#           
#           sample_one_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_one))
#           sample_two_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_two))
#           
#           # Calculate Manhattan distance
#           distance_mut <- dist(rbind(sample_one_mut_vector, sample_two_mut_vector), method = "manhattan")
#           distance_onc <- dist(rbind(sample_one_onc_vector, sample_two_onc_vector), method = "manhattan")
#           
#           mut_async_Manhattan <- append(mut_async_Manhattan, distance_mut)
#           oncogenic_async_Manhattan <- append(oncogenic_async_Manhattan, distance_onc)
#         }
#       }
#     }
#     
#     
#     if(nrow(subset_table) == 1) {
#       next
#     }
#     for (j in 1:(nrow(subset_table) - 1)) {
#       for (k in (j+1):(nrow(subset_table))) {
#         row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
#         row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
#         sample_one <- subset_table$sample_ID[j]
#         sample_two <- subset_table$sample_ID[k]
#         
#         num_pairs_async <- num_pairs_async + 1
#         
#         # Calculate Manhattan distance between two samples
#         sample_one_mut_vector <- as.vector(subset(mut_tab, select = sample_one))
#         sample_two_mut_vector <- as.vector(subset(mut_tab, select = sample_two))
#         
#         sample_one_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_one))
#         sample_two_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_two))
#         
#         # Calculate Manhattan distance
#         distance_mut <- dist(rbind(sample_one_mut_vector, sample_two_mut_vector), method = "manhattan")
#         distance_onc <- dist(rbind(sample_one_onc_vector, sample_two_onc_vector), method = "manhattan")
#         
#         mut_async_Manhattan <- append(mut_async_Manhattan, distance_mut)
#         oncogenic_async_Manhattan <- append(oncogenic_async_Manhattan, distance_onc)
#       }
#     }
#   }
#   
#   # Perform Wilcoxon signed-rank test
#   result <- wilcox.test(oncogenic_sync_Manhattan, oncogenic_async_Manhattan, paired = FALSE)
#   p_value <- result$p.value
#   
#   # print means of both synchronous and asynchronous
#   # if(d == 1) {
#   #   print(table(mut_async_Jaccard)["0"])
#   #   # print(mean(mut_async_Jaccard))
#   # }
#   
#   # print(mut_async_Jaccard)
#   # print("Cheese")
#   
#   # create the actual boxplot using mut_sync_Jaccard and oncogenic_sync_Jaccard and async
#   
#   cancer_plot <- cancer_type_added[d]
# 
#   # Combine the vectors into a data frame
#   data <- data.frame(Category = factor(rep(c("Synchronous", "Asynchronous"),
#                                   times = c(length(oncogenic_sync_Manhattan), length(oncogenic_async_Manhattan))),
#                                   levels = c("Synchronous", "Asynchronous")),
#                    Manhattan = c(oncogenic_sync_Manhattan, oncogenic_async_Manhattan))
#   
#   # Create the boxplot using ggplot2
#   boxplot <- ggplot(data, aes(x = Category, y = Manhattan, fill = Category)) +
#     geom_boxplot() +
#     labs(caption = p_value, x = "Category", y = "Manhattan Distance", title = paste0("Oncogenic Mutations Manhattan Distance for ", cancer_plot, " (# Sync Pairs: ", num_pairs_sync, " # Async Pairs: ", num_pairs_async, ")")) +
#     scale_fill_manual(values = c("blue", "red")) +
#     theme_bw() +
#     theme(plot.caption = element_text(size = 14))
#   
#   # Add the box plot to the list
#   box_plots[[d]] <- boxplot
# }
# figure <- cowplot::plot_grid(plotlist = box_plots, nrow = 4, ncol = 4)
# 
# png("Manhattanprimoncogenicmutations.png", width = 2600, height = 1350)
# figure
# dev.off()
```

```{r}
# Manhattan distance for atleast 1 of both categories
# box_plots <- list()
# 
# for(d in 1:16) {
#   num_pairs_sync <- 0
#   num_pairs_async <- 0
#   
#   sync_type_studied <- get(paste0("both_geq_sync_", d))
#   async_type_studied <- get(paste0("both_geq_async_", d))
#   
#   mut_sync_Manhattan <- c()
#   oncogenic_sync_Manhattan <- c()
#   
#   mut_async_Manhattan <- c()
#   oncogenic_async_Manhattan <- c()
# 
#   num_rows <- length(sync_type_studied)
#   if(num_rows < 1) {next}
# 
#   # create empty vectors for each column
#   sample_ID <- character(num_rows)
#   patient_ID <- character(num_rows)
#   date_acquired <- integer(num_rows)
#   
#   for (i in 1:num_rows) {
#     sample_ID[i] <- sync_type_studied[i]
#     clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
#     patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
#     patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
#     date_acquired[i] <- Dates$START_DATE[patient_ID_index]
#   }
#   
#   # create a table with 3 columns and length(cancer_type_studied) rows
#   table <- data.frame(sample_ID, patient_ID, date_acquired)
#   distinct_patients <- unique(patient_ID)
#   
#   for (i in 1:length(distinct_patients)) {
#     subset_table <- subset(table, patient_ID == distinct_patients[i])
#     subset_table <- subset_table[order(subset_table$date_acquired),]
#     if(nrow(subset_table) == 1) {
#       next
#     }
#     for (j in 1:(nrow(subset_table) - 1)) {
#       for (k in (j+1):(nrow(subset_table))) {
#         row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
#         row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
#         if((Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") | (Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary")) {
#           sample_one <- subset_table$sample_ID[j]
#           sample_two <- subset_table$sample_ID[k]
#           
#           if(!is.na(subset(mut_tab, select = sample_one)) & !is.na(subset(mut_tab, select = sample_two))) {
#             num_pairs_sync <- num_pairs_sync + 1
#             # Calculate Manhattan distance between two samples
#             sample_one_mut_vector <- as.vector(subset(mut_tab, select = sample_one))
#             sample_two_mut_vector <- as.vector(subset(mut_tab, select = sample_two))
#             
#             sample_one_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_one))
#             sample_two_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_two))
#             
#             # Calculate Manhattan distance
#             distance_mut <- dist(rbind(sample_one_mut_vector, sample_two_mut_vector), method = "manhattan")
#             distance_onc <- dist(rbind(sample_one_onc_vector, sample_two_onc_vector), method = "manhattan")
#             
#             mut_sync_Manhattan <- append(mut_sync_Manhattan, distance_mut)
#             oncogenic_sync_Manhattan <- append(oncogenic_sync_Manhattan, distance_onc)
#           }
#         }
#       }
#     }
#   }
#   
#   # repeat analysis for async
#   
#   num_rows <- length(async_type_studied)
#   if(num_rows < 1) {next}
# 
#   # create empty vectors for each column
#   sample_ID <- character(num_rows)
#   patient_ID <- character(num_rows)
#   date_acquired <- integer(num_rows)
#   for (i in 1:num_rows) {
#     sample_ID[i] <- async_type_studied[i]
#     clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
#     patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
#     patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
#     date_acquired[i] <- Dates$START_DATE[patient_ID_index]
#   }
#   
#   # create a table with 3 columns and length(cancer_type_studied) rows
#   table <- data.frame(sample_ID, patient_ID, date_acquired)
#   distinct_patients <- unique(patient_ID)
#   
#   sync_version <- get(paste0("both_geq_sync_", d))
#   
#   for (i in 1:length(distinct_patients)) {
#     subset_table <- subset(table, patient_ID == distinct_patients[i])
#     subset_table <- subset_table[order(subset_table$date_acquired),]
# 
#     values_in_sync <- sync_version[grep(distinct_patients[i], sync_version)]
#     if(length(values_in_sync) > 0) {
#       for (j in 1:nrow(subset_table)) {
#         for(k in 1:length(values_in_sync)) {
#           sample_id <- values_in_sync[k]
#           
#           async_val_index <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
#           sync_val_index <- which(Clinical$SAMPLE_ID == sample_id)
#           
#           if((Clinical$SAMPLE_TYPE[async_val_index] == "Primary" & Clinical$SAMPLE_TYPE[sync_val_index] == "Metastasis") | (Clinical$SAMPLE_TYPE[async_val_index] == "Metastasis" & Clinical$SAMPLE_TYPE[sync_val_index] == "Primary")) {
#             sample_one <- subset_table$sample_ID[j]
#             sample_two <- sample_id
#             
#             if(!is.na(subset(mut_tab, select = sample_one)) & !is.na(subset(mut_tab, select = sample_two))) {
#               num_pairs_async <- num_pairs_async + 1
#               # Calculate Manhattan distance between two samples
#               sample_one_mut_vector <- as.vector(subset(mut_tab, select = sample_one))
#               sample_two_mut_vector <- as.vector(subset(mut_tab, select = sample_two))
#               
#               sample_one_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_one))
#               sample_two_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_two))
#               
#               # Calculate Manhattan distance
#               distance_mut <- dist(rbind(sample_one_mut_vector, sample_two_mut_vector), method = "manhattan")
#               distance_onc <- dist(rbind(sample_one_onc_vector, sample_two_onc_vector), method = "manhattan")
#               
#               mut_async_Manhattan <- append(mut_async_Manhattan, distance_mut)
#               oncogenic_async_Manhattan <- append(oncogenic_async_Manhattan, distance_onc)
#             }
#           }
#         }
#       }
#     }
#     
#     if(nrow(subset_table) == 1) {
#       next
#     }
#     for (j in 1:(nrow(subset_table) - 1)) {
#       for (k in (j+1):(nrow(subset_table))) {
#         row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
#         row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
#         if((Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") | (Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary")) {
#           sample_one <- subset_table$sample_ID[j]
#           sample_two <- subset_table$sample_ID[k]
#           
#           if(!is.na(subset(mut_tab, select = sample_one)) & !is.na(subset(mut_tab, select = sample_two))) {
#             num_pairs_async <- num_pairs_async + 1
#             # Calculate Manhattan distance between two samples
#             sample_one_mut_vector <- as.vector(subset(mut_tab, select = sample_one))
#             sample_two_mut_vector <- as.vector(subset(mut_tab, select = sample_two))
#             
#             sample_one_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_one))
#             sample_two_onc_vector <- as.vector(subset(oncogenic_tab, select = sample_two))
#             
#             # Calculate Manhattan distance
#             distance_mut <- dist(rbind(sample_one_mut_vector, sample_two_mut_vector), method = "manhattan")
#             distance_onc <- dist(rbind(sample_one_onc_vector, sample_two_onc_vector), method = "manhattan")
#             
#             mut_async_Manhattan <- append(mut_async_Manhattan, distance_mut)
#             oncogenic_async_Manhattan <- append(oncogenic_async_Manhattan, distance_onc)
#           }
#         }
#       }
#     }
#   }
#   
#   # Perform Wilcoxon signed-rank test
#   result <- wilcox.test(oncogenic_sync_Manhattan, oncogenic_async_Manhattan, paired = FALSE)
#   p_value <- result$p.value
#   
#   # create the actual boxplot using mut_sync_Jaccard and oncogenic_sync_Jaccard and async
# 
#   cancer_plot <- cancer_type_added[d]
# 
#   # Combine the vectors into a data frame
#   data <- data.frame(Category = factor(rep(c("Synchronous", "Asynchronous"),
#                                   times = c(length(oncogenic_sync_Manhattan), length(oncogenic_async_Manhattan))),
#                                   levels = c("Synchronous", "Asynchronous")),
#                    Manhattan = c(oncogenic_sync_Manhattan, oncogenic_async_Manhattan))
#   
#   # Create the boxplot using ggplot2
#   boxplot <- ggplot(data, aes(x = Category, y = Manhattan, fill = Category)) +
#     geom_boxplot() +
#     labs(caption = p_value, x = "Category", y = "Manhattan Distance", title = paste0("Oncogenic Mutations Manhattan Distance for ", cancer_plot, " (# Sync Pairs: ", num_pairs_sync, " # Async Pairs: ", num_pairs_async, ")")) +
#     scale_fill_manual(values = c("blue", "red")) +
#     theme_bw() +
#     theme(plot.caption = element_text(size = 14))
#   
#   # Add the box plot to the list
#   box_plots[[d]] <- boxplot
# }
# figure <- cowplot::plot_grid(plotlist = box_plots, nrow = 4, ncol = 4)
# 
# png("Manhattanoncogenicmutations.png", width = 2600, height = 1350)
# figure
# dev.off()
```


```{r}
# Bladder Boxplot Breakdown By Metastatic Site for tumor purity, log(TMB), FGA
num_pairs_lymph <- 0
num_pairs_other <- 0

lymph_node <- c("Lymph Node", "Lymph node")
prim_purity_lymph <- c()
met_purity_lymph <- c()

prim_purity_other <- c()
met_purity_other <- c()

num_rows <- length(both_geq_sync_4)

sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
tumor_purity <- numeric(num_rows)
# TMB <- numeric(num_rows)
# FGA <- numeric(num_rows)
date_acquired <- integer(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- both_geq_sync_4[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
  tumor_purity[i] <- Clinical$TUMOR_PURITY[clin_ind]
}

# create a table with 4 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, tumor_purity, date_acquired)

distinct_patients <- unique(patient_ID)

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  # remove patients that only have 1 asynchronous primary sample (means they originally had 3 primary samples but 2 were synchronous and last one not)
  if(nrow(subset_table) == 1) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
      row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
      if(Clinical$SAMPLE_TYPE[row_ind_k] == "Primary" & Clinical$SAMPLE_TYPE[row_ind_j] == "Metastasis") {
        if(!is.na(subset_table$tumor_purity[k]) & !is.na(subset_table$tumor_purity[j])) {
          if(Clinical$METASTATIC_SITE[row_ind_j] %in% lymph_node) {
            prim_purity_lymph <- append(prim_purity_lymph, subset_table$tumor_purity[k])
            met_purity_lymph <- append(met_purity_lymph, subset_table$tumor_purity[j])
            num_pairs_lymph <- num_pairs_lymph+1
          }
          else {
            prim_purity_other <- append(prim_purity_other, subset_table$tumor_purity[k])
            met_purity_other <- append(met_purity_other, subset_table$tumor_purity[j])
            num_pairs_other <- num_pairs_other+1
          }
        }
      }
      if(Clinical$SAMPLE_TYPE[row_ind_k] == "Metastasis" & Clinical$SAMPLE_TYPE[row_ind_j] == "Primary") {
        if(!is.na(subset_table$tumor_purity[k]) & !is.na(subset_table$tumor_purity[j])) {
          if(Clinical$METASTATIC_SITE[row_ind_k] %in% lymph_node) {
            prim_purity_lymph <- append(prim_purity_lymph, subset_table$tumor_purity[j])
            met_purity_lymph <- append(met_purity_lymph, subset_table$tumor_purity[k])
            num_pairs_lymph <- num_pairs_lymph+1
          }
          else {
            prim_purity_other <- append(prim_purity_other, subset_table$tumor_purity[j])
            met_purity_other <- append(met_purity_other, subset_table$tumor_purity[k])
            num_pairs_other <- num_pairs_other+1
          }
        }
      }
    }
  }
}

# Perform Wilcoxon signed-rank test for lymph nodes
prim_purity_lymph <- as.numeric(prim_purity_lymph)
met_purity_lymph <- as.numeric(met_purity_lymph)
result <- wilcox.test(prim_purity_lymph, met_purity_lymph, paired = TRUE)
p_value_lymph <- result$p.value
p_value_lymph <- round(p_value_lymph, digits = 5)

# Perform Wilcoxon signed-rank test for other met sites
prim_purity_other <- as.numeric(prim_purity_other)
met_purity_other <- as.numeric(met_purity_other)
result <- wilcox.test(prim_purity_other, met_purity_other, paired = TRUE)
p_value_other <- result$p.value
p_value_other <- round(p_value_other, digits = 5)

data <- data.frame(Primary = prim_purity_lymph, Metastasis = met_purity_lymph)
data$Index <- seq_along(prim_purity_lymph)

# Reshape the data frame into long format
data_long <- reshape2::melt(data, id.vars = "Index")

# Create a factor variable for the variable column with the desired order
data_long$variable <- factor(data_long$variable, levels = c("Primary", "Metastasis"))

# data_long <- gather(data, key = "Group", value = "Value", Primary, Metastasis)
boxplot_lymph <- ggplot(data_long, aes(x = variable, y = value, fill = variable)) +
  geom_boxplot() +
  geom_line(aes(group = Index), color = "blue")+
  labs(x = "Group", y = "Tumor Purity", title = paste0("Bladder Cancer Lymph Node Met Site ", " (N = ", num_pairs_lymph, ")"), caption = paste0("p-value: ", p_value_lymph), fill = "Category") +
  theme_minimal() +
  theme(plot.caption = element_text(size = 50))+
  theme(plot.title = element_text(size = 50))+
  theme(axis.text.x = element_text(size = 50))+
  theme(axis.text.y = element_text(size = 50)) + 
  theme(axis.title.x = element_text(size = 50))+
  theme(axis.title.y = element_text(size = 50))+
  theme(legend.text =element_text(size = 35)) +
  theme(legend.title = element_text(size = 35))


data <- data.frame(Primary = prim_purity_other, Metastasis = met_purity_other)
data$Index <- seq_along(prim_purity_other)

# Reshape the data frame into long format
data_long <- reshape2::melt(data, id.vars = "Index")

# Create a factor variable for the variable column with the desired order
data_long$variable <- factor(data_long$variable, levels = c("Primary", "Metastasis"))

# data_long <- gather(data, key = "Group", value = "Value", Primary, Metastasis)
boxplot_other <- ggplot(data_long, aes(x = variable, y = value, fill = variable)) +
  geom_boxplot() +
  geom_line(aes(group = Index), color = "blue")+
  labs(x = "Group", y = "Tumor Purity", title = paste0("Bladder Cancer Non-Lymph Node Met Site ", " (N = ", num_pairs_other, ")"), caption = paste0("p-value: ", p_value_other), fill = "Category") +
  theme_minimal() +
  theme(plot.caption = element_text(size = 50))+
  theme(plot.title = element_text(size = 50))+
  theme(axis.text.x = element_text(size = 50))+
  theme(axis.text.y = element_text(size = 50)) + 
  theme(axis.title.x = element_text(size = 50))+
  theme(axis.title.y = element_text(size = 50))+
  theme(legend.text =element_text(size = 35)) +
  theme(legend.title = element_text(size = 35))

box_plots <- list(boxplot_lymph, boxplot_other)

figure <- cowplot::plot_grid(plotlist = box_plots, nrow = 1, ncol = 2)
png("bladderlymphtumorpurity.png", width = 2800, height = 1250)
figure
dev.off()


# # acquire most common metastatic sites for geq 1 for bladder
# for(i in 1:length(both_geq_async_4)) {
#   clin_ind <- which(Clinical$SAMPLE_ID == both_geq_sync_4[i])
#   if(Clinical$METASTATIC_SITE[clin_ind] == "Lymph Node" | Clinical$METASTATIC_SITE[clin_ind] == "Lymph node") {
#     
#   }
#   else {
#     
#   }
#      & Clinical$METASTATIC_SITE[clin_ind] != "Not Applicable") {
#     met_site <- append(met_site, Clinical$METASTATIC_SITE[clin_ind])
#   }
# }
# 
# for (i in met_sites) {
# 
# }
# 
# # Count occurrences of each unique value
# result <- table(met_site)
# print(result)

# Sort the result in descending order and select the top 10 values
# top_10_values <- head(sort(result, decreasing = TRUE), 10)
# 
# # Print the top 10 values
# print(top_10_values)
# WHY IS IT ONLY 42 WHAT HAPPENED TO THE PAIRS
```


```{r}
# create Mutex for synchronous pairs of primaries from LUAD
# V0.1 Evan Seffar - seffare@mskcc.org

FromGAMtoPlot <- function(df, pathway = FALSE) {
  if (!pathway) {
    # Remove mutations with n=3
    col_counts <- colSums(df)
    df <- df[, col_counts >= 3]
  }
  
  # The dataframe (df) should be a binary matrix where rows are samples, columns are genes, and each entry is 0 or 1.
  # If pathway is TRUE, sum the alterations at the pathway level.
  if (pathway) {
    gene_to_pathway <- read.table("~/Downloads/Pathway_Groupings.txt", sep = '\t', header = TRUE) %>% drop_na()
    # Store order of Pathway column
    pathway_order <- unique(gene_to_pathway$Pathway)
    # Define the pathways for each gene.
    # Transpose the dataframe to have genes as rows and samples as columns
    df <- as.data.frame(t(df))
    # Join the input data frame with the gene_to_pathway data frame to add a Pathway column
    df <- merge(df, gene_to_pathway, by.x = "row.names", by.y = "Hugo_symbol")
    row.names(df) <- df$Row.names  # Preserve the original row names
    df$Row.names <- NULL
    # Sum the alterations at the pathway level
    df <- df %>% group_by(Pathway) %>% summarise_all(function(x) as.integer(sum(x) > 0))
    df <- ungroup(df)
    # Print the total number of alterations per pathway
    total_alterations <- rowSums(df[,-1])  # Excluding the 'Pathway' column
    df$Total_alterations <- total_alterations
    # print(df %>% select(Pathway, Total_alterations))
    
    df <- df %>% column_to_rownames(var = "Pathway")    # Replace the row names with the pathway names
    df$Total_alterations <- NULL  # Remove the 'Total_alterations' column before transposing
    df <- as.data.frame(t(df))
  }
  
  # Store a copy of the original genes or pathways
  original_genes_or_pathways <- colnames(df)
  # Extract column names, assumed to be gene names.
  genes <- colnames(df)
  genes_order <- genes
  
  # Count the alterations for each gene.
  gene_counts <- colSums(df > 0)
  genes_with_counts <- paste0(genes, " (n = ", gene_counts, ")")
  
  # Initialize matrices to store the log2 odds ratios and p-values.
  log2_OR_matrix <- matrix(nrow = length(genes), ncol = length(genes))
  pvalue_matrix <- matrix(nrow = length(genes), ncol = length(genes))
  
  if (pathway) {
    # legend position and title for pathway
    legend_position <- c(.22, .75)
    legend_labels <- c("Co-occurring", " ","Mutually exclusive")
    y_labels <- genes  # 'y' axis labels with counts
    x_labels <- genes_with_counts               # 'x' axis labels without counts
    
    rownames(log2_OR_matrix) <- x_labels  
    colnames(log2_OR_matrix) <- y_labels              
    rownames(pvalue_matrix) <- x_labels  
    colnames(pvalue_matrix) <- y_labels 
    # print(head(log2_OR_matrix))
  } else {
    # legend position and title for gene
    legend_position <- c(.78, .32)
    legend_labels <- c("Mutually exclusive", "    ","Co-occurring")
    y_labels <- genes   # 'y' axis labels without counts
    x_labels <- genes_with_counts   # 'x' axis labels with counts
    
    rownames(log2_OR_matrix) <- y_labels  
    colnames(log2_OR_matrix) <- x_labels              
    rownames(pvalue_matrix) <- y_labels  
    colnames(pvalue_matrix) <- x_labels 
    # print(head(log2_OR_matrix))
    
  }
  
  # Loop over all possible pairs of genes.
  for (i in seq_along(genes)) {
    for (j in seq_along(genes)) {
      # Only proceed if both genes have at least 2 distinct values.
      if (length(unique(df[, genes[i]])) > 1 && length(unique(df[, genes[j]])) > 1) {
        # Create a contingency table of the presence/absence patterns of the two genes.
        table <- table(df[, genes[i]], df[, genes[j]])
        # Conduct Fisher's exact test on the contingency table.
        test_result <- fisher.test(table)
        # Extract the log2 odds ratio and p-value.
        log2_OR_matrix[i, j] <- log2(test_result$estimate)
        pvalue_matrix[i, j] <- test_result$p.value
      } else {
        # Assign NA values to the pair with insufficient diversity.
        log2_OR_matrix[i, j] <- NA
        pvalue_matrix[i, j] <- NA
      }
    }
  }
  
  # Apply FDR correction to p-values to get q-values.
  qvalue_matrix <- p.adjust(pvalue_matrix, method = "fdr")
  
  # Melt the log2_OR_matrix to create a data frame
  # that can be used in ggplot.
  finaldf <- reshape2::melt(log2_OR_matrix)
  
  # Add the q-values as a new column in this data frame.
  finaldf$qvalue <- reshape2::melt(qvalue_matrix)$value
  
  # Rename columns.
  names(finaldf) <- c("GENE_A", "GENE_B", "value", "qvalue")
  
  # Convert factors to characters to allow for comparison.
  finaldf$GENE_A <- as.character(finaldf$GENE_A)
  finaldf$GENE_B <- as.character(finaldf$GENE_B)
  # Filter data to keep only the lower half of the matrix.
  finaldf <- finaldf[finaldf$GENE_A <= finaldf$GENE_B, ]
  
  # Replace self-correlation values with NA.
  # Strip counts from gene names.
  GENE_A_without_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_A)
  GENE_B_without_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_B)
  # print(head(finaldf))                                        
  # Replace self-correlation values with NA.
  finaldf$value <- ifelse(GENE_A_without_counts == GENE_B_without_counts, NA, finaldf$value)
  finaldf$qvalue <- ifelse(GENE_A_without_counts == GENE_B_without_counts, NA, finaldf$qvalue)
  finaldf$value <- ifelse(GENE_B_without_counts == GENE_A_without_counts, NA, finaldf$value)
  finaldf$qvalue <- ifelse(GENE_B_without_counts == GENE_A_without_counts, NA, finaldf$qvalue)
  # Replace infinite values with 0.
  finaldf <- finaldf %>% mutate(value = ifelse(is.infinite(value), 0, value))
  
  # Transpose the finaldf data frame
  finaldf <- finaldf[order(finaldf$GENE_A, decreasing = FALSE), ]
  finaldf <- finaldf[order(finaldf$GENE_B, decreasing = FALSE), ]
  finaldf$GENE_A_no_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_A)
  finaldf$GENE_B_no_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_B)
  if (pathway) {
    finaldf$GENE_A_no_counts <- factor(finaldf$GENE_A_no_counts, levels = pathway_order)
    finaldf$GENE_B_no_counts <- factor(finaldf$GENE_B_no_counts, levels = pathway_order)
  } else {
    finaldf$GENE_A_no_counts <- factor(finaldf$GENE_A_no_counts, levels = genes_order)
    finaldf$GENE_B_no_counts <- factor(finaldf$GENE_B_no_counts, levels = genes_order)
  }                                              
  # Create a heatmap of the log2 odds ratios.
  plot <- ggplot(finaldf, 
                 aes_string(
                   y = "GENE_B", 
                   x = "GENE_A", 
                   fill = "value"
                 )) + 
    geom_tile(color = "black") + 
    scale_fill_gradient2(low = "#710193", 
                         high = "darkgreen", 
                         mid = "white", 
                         midpoint = 0, 
                         limits = c(-3,3), 
                         name = "log2(OR)",
                         breaks = c(-3, 0, 3),
                         oob = scales::squish,  # Values outside of limits are squished to the closest limit
                         labels = c("Mutually exclusive", "    ","Co-occurring"),
                         guide = guide_colorbar(direction = "horizontal", title.position = "top")) + 
    
    # Add significance stars
    geom_text(data = subset(finaldf, qvalue <= 0.05), 
              aes(label = ifelse(qvalue <= 0.001, "***", ifelse(qvalue <= 0.01, "**", ifelse(qvalue <= 0.05, "*", "")))), 
              color = "white", size = 15, vjust = 0.75) +
    
    # Move x-axis to the bottom and remove labels
    scale_x_discrete(position = "top") + #ifelse(pathway, "bottom", "top")) +
    # scale_y_discrete(position = ifelse(pathway, "right", "left"))+
    labs(x = NULL, y = NULL) + 
    
    # Apply classic theme and remove panel border, axis ticks and axis lines
    theme_classic() + 
    theme(axis.text.x = element_text(angle = 45, hjust = ifelse(pathway, 1, 0.1)),
          panel.border = element_blank(),
          axis.ticks = element_blank(),
          axis.line = element_blank(),
          plot.margin = margin(1, 1, 1, 1, "cm"),
          # Move legend inside plot
          legend.position = legend_position) 
  
  # Flip coordinates if pathway argument is TRUE
  if (pathway) {
    plot <- plot + coord_flip()
  }
  return(plot)
}

cancer_type <- prim[[LUAD]]
num_rows <- length(cancer_type)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)

for (i in 1:num_rows) {
  sample_ID[i] <- cancer_type[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and prim_sync_11 rows
table <- data.frame(sample_ID, patient_ID, date_acquired)
distinct_patients <- unique(patient_ID)

first_pair <- c()
second_pair <- c()

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  if(nrow(subset_table) != 2) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      if((subset_table$date_acquired[k] - subset_table$date_acquired[j]) > SYNC_MARK) {
        next
      }
      row_ind_k <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[k])
      row_ind_j <- which(Clinical$SAMPLE_ID == subset_table$sample_ID[j])
      sample_one <- subset_table$sample_ID[j]
      sample_two <- subset_table$sample_ID[k]
      
      if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
        first_pair <- append(first_pair, sample_one)
        second_pair <- append(second_pair, sample_two)
      }
    }
  }
}

# Subset the matrix to include only the desired columns
sync_matrix_1 <- oncogenic_tab[, colnames(oncogenic_tab) %in% first_pair]
zero_rows <- which(rowSums(sync_matrix_1 == 0) == ncol(sync_matrix_1))
sync_matrix_1 <- sync_matrix_1[-zero_rows, ]
sync_matrix_2 <- oncogenic_tab[, colnames(oncogenic_tab) %in% second_pair]
zero_rows <- which(rowSums(sync_matrix_2 == 0) == ncol(sync_matrix_2))
sync_matrix_2 <- sync_matrix_2[-zero_rows, ]

# Transpose the matrices
t_sync_matrix_1 <- t(sync_matrix_1)
t_sync_matrix_2 <- t(sync_matrix_2)

# unique_indices <- unique(c(colnames(t_sync_matrix_1), colnames(t_sync_matrix_1)))
# print(unique_indices)

# The plot
plot <- FromGAMtoPlot(t_sync_matrix_1,pathway = FALSE)
# png("mutexsync1.png", width = 4000, height = 2000, res = 300)
plot
# Close device
# dev.off()

# plot <- FromGAMtoPlot(t_sync_matrix_2,pathway = FALSE)
# png("mutexsync2.png", width = 4000, height = 2000, res = 300)
# plot
# Close device
# dev.off()
```

```{r}
# now asynchronous

# V0.1 Evan Seffar - seffare@mskcc.org

FromGAMtoPlot <- function(df, pathway = FALSE) {
  # if (!pathway) {
  #   # Remove mutations with n=3
  #   col_counts <- colSums(df)
  #   df <- df[, col_counts >= 3]
  # }
  
  # The dataframe (df) should be a binary matrix where rows are samples, columns are genes, and each entry is 0 or 1.
  # If pathway is TRUE, sum the alterations at the pathway level.
  if (pathway) {
    gene_to_pathway <- read.table("~/Downloads/Pathway_Groupings.txt", sep = '\t', header = TRUE) %>% drop_na()
    # Store order of Pathway column
    pathway_order <- unique(gene_to_pathway$Pathway)
    # Define the pathways for each gene.
    # Transpose the dataframe to have genes as rows and samples as columns
    df <- as.data.frame(t(df))
    # Join the input data frame with the gene_to_pathway data frame to add a Pathway column
    df <- merge(df, gene_to_pathway, by.x = "row.names", by.y = "Hugo_symbol")
    row.names(df) <- df$Row.names  # Preserve the original row names
    df$Row.names <- NULL
    # Sum the alterations at the pathway level
    df <- df %>% group_by(Pathway) %>% summarise_all(function(x) as.integer(sum(x) > 0))
    df <- ungroup(df)
    # Print the total number of alterations per pathway
    total_alterations <- rowSums(df[,-1])  # Excluding the 'Pathway' column
    df$Total_alterations <- total_alterations
    # print(df %>% select(Pathway, Total_alterations))
    
    df <- df %>% column_to_rownames(var = "Pathway")    # Replace the row names with the pathway names
    df$Total_alterations <- NULL  # Remove the 'Total_alterations' column before transposing
    df <- as.data.frame(t(df))
  }
  
  # Store a copy of the original genes or pathways
  original_genes_or_pathways <- colnames(df)
  # Extract column names, assumed to be gene names.
  genes <- colnames(df)
  genes_order <- genes
  
  # Count the alterations for each gene.
  gene_counts <- colSums(df > 0)
  genes_with_counts <- paste0(genes, " (n = ", gene_counts, ")")
  
  # Initialize matrices to store the log2 odds ratios and p-values.
  log2_OR_matrix <- matrix(nrow = length(genes), ncol = length(genes))
  pvalue_matrix <- matrix(nrow = length(genes), ncol = length(genes))
  
  if (pathway) {
    # legend position and title for pathway
    legend_position <- c(.22, .75)
    legend_labels <- c("Co-occurring", " ","Mutually exclusive")
    y_labels <- genes  # 'y' axis labels with counts
    x_labels <- genes_with_counts               # 'x' axis labels without counts
    
    rownames(log2_OR_matrix) <- x_labels  
    colnames(log2_OR_matrix) <- y_labels              
    rownames(pvalue_matrix) <- x_labels  
    colnames(pvalue_matrix) <- y_labels 
    # print(head(log2_OR_matrix))
  } else {
    # legend position and title for gene
    legend_position <- c(.78, .32)
    legend_labels <- c("Mutually exclusive", "    ","Co-occurring")
    y_labels <- genes   # 'y' axis labels without counts
    x_labels <- genes_with_counts   # 'x' axis labels with counts
    
    rownames(log2_OR_matrix) <- y_labels  
    colnames(log2_OR_matrix) <- x_labels              
    rownames(pvalue_matrix) <- y_labels  
    colnames(pvalue_matrix) <- x_labels 
    # print(head(log2_OR_matrix))
    
  }
  
  # Loop over all possible pairs of genes.
  for (i in seq_along(genes)) {
    for (j in seq_along(genes)) {
      # Only proceed if both genes have at least 2 distinct values.
      if (length(unique(df[, genes[i]])) > 1 && length(unique(df[, genes[j]])) > 1) {
        # Create a contingency table of the presence/absence patterns of the two genes.
        table <- table(df[, genes[i]], df[, genes[j]])
        # Conduct Fisher's exact test on the contingency table.
        test_result <- fisher.test(table)
        # Extract the log2 odds ratio and p-value.
        log2_OR_matrix[i, j] <- log2(test_result$estimate)
        pvalue_matrix[i, j] <- test_result$p.value
      } else {
        # Assign NA values to the pair with insufficient diversity.
        log2_OR_matrix[i, j] <- NA
        pvalue_matrix[i, j] <- NA
      }
    }
  }
  
  # Apply FDR correction to p-values to get q-values.
  qvalue_matrix <- p.adjust(pvalue_matrix, method = "fdr")
  
  # Melt the log2_OR_matrix to create a data frame
  # that can be used in ggplot.
  finaldf <- reshape2::melt(log2_OR_matrix)
  
  # Add the q-values as a new column in this data frame.
  finaldf$qvalue <- reshape2::melt(qvalue_matrix)$value
  
  # Rename columns.
  names(finaldf) <- c("GENE_A", "GENE_B", "value", "qvalue")
  
  # Convert factors to characters to allow for comparison.
  finaldf$GENE_A <- as.character(finaldf$GENE_A)
  finaldf$GENE_B <- as.character(finaldf$GENE_B)
  # Filter data to keep only the lower half of the matrix.
  finaldf <- finaldf[finaldf$GENE_A <= finaldf$GENE_B, ]
  
  # Replace self-correlation values with NA.
  # Strip counts from gene names.
  GENE_A_without_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_A)
  GENE_B_without_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_B)
  # print(head(finaldf))                                        
  # Replace self-correlation values with NA.
  finaldf$value <- ifelse(GENE_A_without_counts == GENE_B_without_counts, NA, finaldf$value)
  finaldf$qvalue <- ifelse(GENE_A_without_counts == GENE_B_without_counts, NA, finaldf$qvalue)
  finaldf$value <- ifelse(GENE_B_without_counts == GENE_A_without_counts, NA, finaldf$value)
  finaldf$qvalue <- ifelse(GENE_B_without_counts == GENE_A_without_counts, NA, finaldf$qvalue)
  # Replace infinite values with 0.
  finaldf <- finaldf %>% mutate(value = ifelse(is.infinite(value), 0, value))
  
  # Transpose the finaldf data frame
  finaldf <- finaldf[order(finaldf$GENE_A, decreasing = FALSE), ]
  finaldf <- finaldf[order(finaldf$GENE_B, decreasing = FALSE), ]
  finaldf$GENE_A_no_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_A)
  finaldf$GENE_B_no_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_B)
  if (pathway) {
    finaldf$GENE_A_no_counts <- factor(finaldf$GENE_A_no_counts, levels = pathway_order)
    finaldf$GENE_B_no_counts <- factor(finaldf$GENE_B_no_counts, levels = pathway_order)
  } else {
    finaldf$GENE_A_no_counts <- factor(finaldf$GENE_A_no_counts, levels = genes_order)
    finaldf$GENE_B_no_counts <- factor(finaldf$GENE_B_no_counts, levels = genes_order)
  }                                              
  # Create a heatmap of the log2 odds ratios.
  plot <- ggplot(finaldf, 
                 aes_string(
                   y = "GENE_B", 
                   x = "GENE_A", 
                   fill = "value"
                 )) + 
    geom_tile(color = "black") + 
    scale_fill_gradient2(low = "#710193", 
                         high = "darkgreen", 
                         mid = "white", 
                         midpoint = 0, 
                         limits = c(-3,3), 
                         name = "log2(OR)",
                         breaks = c(-3, 0, 3),
                         oob = scales::squish,  # Values outside of limits are squished to the closest limit
                         labels = c("Mutually exclusive", "    ","Co-occurring"),
                         guide = guide_colorbar(direction = "horizontal", title.position = "top", 
                                              title.hjust = 0.5,        # Center the title horizontally
                                              title.size = 20,          # Increase font size of the title
                                              # keywidth = unit(50, "cm"), # Increase width of the legend key
                                              # keyheight = unit(15, "cm")
                                              )) + 
    
    # Add significance stars
    geom_text(data = subset(finaldf, qvalue <= 0.05), 
              aes(label = ifelse(qvalue <= 0.001, "***", ifelse(qvalue <= 0.01, "**", ifelse(qvalue <= 0.05, "*", "")))), 
              color = "white", size = 18, vjust = 0.75) +
    
    # Move x-axis to the bottom and remove labels
    scale_x_discrete(position = "top") + #ifelse(pathway, "bottom", "top")) +
    # scale_y_discrete(position = ifelse(pathway, "right", "left"))+
    labs(x = NULL, y = NULL) + 
    
    # Apply classic theme and remove panel border, axis ticks and axis lines
    theme_classic() + 
    theme(axis.text.x = element_text(angle = 45, hjust = ifelse(pathway, 1, 0.1), size = 20),
          axis.text.y = element_text(size = 20),  # Decrease row names font size
          panel.border = element_blank(),
          axis.ticks = element_blank(),
          axis.line = element_blank(),
          plot.margin = margin(1, 1, 1, 1, "cm"),
          legend.text = element_text(size = 30),
          legend.title = element_text(size = 40), # Increase font size of the legend title
          # Move legend inside plot
          # keywidth = unit(2.5, "cm"),
          # keyheight = unit(1, "cm"),
          legend.position = legend_position,
          legend.key.width = unit(2, "cm"),    # Increase the width of the legend key
          legend.key.height = unit(1, "cm"))  # Increase the height of the legend key)
    
    # Adjust the size of the legend key
    # guides(fill = guide_legend(override.aes = list(width = unit(2.5, "cm"), height = unit(1, "cm"))))
  
  # Flip coordinates if pathway argument is TRUE
  if (pathway) {
    plot <- plot + coord_flip()
  }
  return(plot)
}

num_rows <- length(prim_11)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)
for (i in 1:num_rows) {
  sample_ID[i] <- async_type_studied[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired)
distinct_patients <- unique(patient_ID)

first_pair <- c()
second_pair <- c()

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  
  # values in prim_sync_3 that have the same patient ID as distinct_patients[i]
  # sync_version <- prim_sync_11
  # values_in_sync <- sync_version[grep(distinct_patients[i], sync_version)]
  # 
  # if(length(values_in_sync) > 0) {
  #   for (j in 1:nrow(subset_table)) {
  #     for(k in 1:length(values_in_sync)) {
  #       sync_sample <- values_in_sync[k]
  #       patient_ID_index <- which(Dates$SAMPLE_ID == sync_sample)
  #       sync_date <- Dates$START_DATE[patient_ID_index]
  #       if(sync_date > subset_table$date_acquired[j]) {
  #         sample_one <- subset_table$sample_ID[j]
  #         sample_two <- sync_sample
  #       }
  #       else{
  #         sample_one <- sync_sample
  #         sample_two <- subset_table$sample_ID[j]
  #       }
  #       row_ind_j <- which(Clinical$SAMPLE_ID == sample_one)
  #       row_ind_k <- which(Clinical$SAMPLE_ID == sample_two)
  #       
  #       if((Clinical$TUMOR_PURITY[row_ind_j] > 20) & (Clinical$TUMOR_PURITY[row_ind_k] > 20)) {
  #         if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
  #           first_pair <- append(first_pair, sample_one)
  #           second_pair <- append(second_pair, sample_two)
  #         }
  #       }
  #     }
  #   }
  # }
  
  if(nrow(subset_table) != 2) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      sample_one <- subset_table$sample_ID[j]
      sample_two <- subset_table$sample_ID[k]
      row_ind_j <- which(Clinical$SAMPLE_ID == sample_one)
      row_ind_k <- which(Clinical$SAMPLE_ID == sample_two)
      
      if((Clinical$TUMOR_PURITY[row_ind_j] <= 20) | (Clinical$TUMOR_PURITY[row_ind_k] <= 20) | (Clinical$TUMOR_PURITY[row_ind_j] == 5)) {
        next
      }
      # if((grepl("Oncogenic", MAF$ONCOGENIC[sample_one_index])) & (grepl("Oncogenic", MAF$ONCOGENIC[sample_two_index]))) {
      if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
        first_pair <- append(first_pair, sample_one)
        second_pair <- append(second_pair, sample_two)
      }
    }
  }
}

# Subset the matrix to include only the desired columns
async_matrix_1 <- oncogenic_tab[, colnames(oncogenic_tab) %in% first_pair]
# zero_rows <- which(rowSums(async_matrix_1 == 0) == ncol(async_matrix_1))
# async_matrix_1 <- async_matrix_1[-zero_rows, ]


async_matrix_2 <- oncogenic_tab[, colnames(oncogenic_tab) %in% second_pair]
# zero_rows <- which(rowSums(async_matrix_2 == 0) == ncol(async_matrix_2))
# async_matrix_2 <- async_matrix_2[-zero_rows, ]

unique_indices <- unique(c(rownames(async_matrix_1), rownames(async_matrix_2)))

async_matrix_1 <- async_matrix_1[rownames(async_matrix_1) %in% unique_indices, ]
async_matrix_2 <- async_matrix_2[rownames(async_matrix_2) %in% unique_indices, ]

# Transpose the matrices
t_async_matrix_1 <- t(async_matrix_1)
t_async_matrix_2 <- t(async_matrix_2)

col_counts_1 <- colSums(t_async_matrix_1)
col_counts_2 <- colSums(t_async_matrix_2)

t_async_matrix_1 <- t_async_matrix_1[, (col_counts_1 >= 3) | (col_counts_2 >= 3)]
t_async_matrix_2 <- t_async_matrix_2[, (col_counts_1 >= 3) | (col_counts_2 >= 3)]


# print(unique_indices)

# The plot
plot <- FromGAMtoPlot(t_async_matrix_1, pathway = FALSE)
# # png("mutexasync1.png", width = 4000, height = 2000, res = 300)
plot
# Close device
# dev.off()

# plot <- FromGAMtoPlot(t_async_matrix_2, pathway = FALSE)
# # png("mutexasync2.png", width = 4000, height = 2000, res = 300)
# plot
# # Close device
# dev.off()

```


```{r}
# asynchronous but adjusting sample categorization to include all pairs
FromGAMtoPlot <- function(df, pathway = FALSE) {
  # if (!pathway) {
  #   # Remove mutations with n=3
  #   col_counts <- colSums(df)
  #   df <- df[, col_counts >= 3]
  # }
  
  # The dataframe (df) should be a binary matrix where rows are samples, columns are genes, and each entry is 0 or 1.
  # If pathway is TRUE, sum the alterations at the pathway level.
  if (pathway) {
    gene_to_pathway <- read.table("~/Downloads/Pathway_Groupings.txt", sep = '\t', header = TRUE) %>% drop_na()
    # Store order of Pathway column
    pathway_order <- unique(gene_to_pathway$Pathway)
    # Define the pathways for each gene.
    # Transpose the dataframe to have genes as rows and samples as columns
    df <- as.data.frame(t(df))
    # Join the input data frame with the gene_to_pathway data frame to add a Pathway column
    df <- merge(df, gene_to_pathway, by.x = "row.names", by.y = "Hugo_symbol")
    row.names(df) <- df$Row.names  # Preserve the original row names
    df$Row.names <- NULL
    # Sum the alterations at the pathway level
    df <- df %>% group_by(Pathway) %>% summarise_all(function(x) as.integer(sum(x) > 0))
    df <- ungroup(df)
    # Print the total number of alterations per pathway
    total_alterations <- rowSums(df[,-1])  # Excluding the 'Pathway' column
    df$Total_alterations <- total_alterations
    # print(df %>% select(Pathway, Total_alterations))
    
    df <- df %>% column_to_rownames(var = "Pathway")    # Replace the row names with the pathway names
    df$Total_alterations <- NULL  # Remove the 'Total_alterations' column before transposing
    df <- as.data.frame(t(df))
  }
  
  # Store a copy of the original genes or pathways
  original_genes_or_pathways <- colnames(df)
  # Extract column names, assumed to be gene names.
  genes <- colnames(df)
  genes_order <- genes
  
  # Count the alterations for each gene.
  gene_counts <- colSums(df > 0)
  genes_with_counts <- paste0(genes, " (n = ", gene_counts, ")")
  
  # Initialize matrices to store the log2 odds ratios and p-values.
  log2_OR_matrix <- matrix(nrow = length(genes), ncol = length(genes))
  pvalue_matrix <- matrix(nrow = length(genes), ncol = length(genes))
  
  if (pathway) {
    # legend position and title for pathway
    legend_position <- c(.22, .75)
    legend_labels <- c("Co-occurring", " ","Mutually exclusive")
    y_labels <- genes  # 'y' axis labels with counts
    x_labels <- genes_with_counts               # 'x' axis labels without counts
    
    rownames(log2_OR_matrix) <- x_labels  
    colnames(log2_OR_matrix) <- y_labels              
    rownames(pvalue_matrix) <- x_labels  
    colnames(pvalue_matrix) <- y_labels 
    # print(head(log2_OR_matrix))
  } else {
    # legend position and title for gene
    legend_position <- c(.78, .32)
    legend_labels <- c("Mutually exclusive", "    ","Co-occurring")
    y_labels <- genes   # 'y' axis labels without counts
    x_labels <- genes_with_counts   # 'x' axis labels with counts
    
    rownames(log2_OR_matrix) <- y_labels  
    colnames(log2_OR_matrix) <- x_labels              
    rownames(pvalue_matrix) <- y_labels  
    colnames(pvalue_matrix) <- x_labels 
    # print(head(log2_OR_matrix))
    
  }
  
  # Loop over all possible pairs of genes.
  for (i in seq_along(genes)) {
    for (j in seq_along(genes)) {
      # Only proceed if both genes have at least 2 distinct values.
      if (length(unique(df[, genes[i]])) > 1 && length(unique(df[, genes[j]])) > 1) {
        # Create a contingency table of the presence/absence patterns of the two genes.
        table <- table(df[, genes[i]], df[, genes[j]])
        # Conduct Fisher's exact test on the contingency table.
        test_result <- fisher.test(table)
        # Extract the log2 odds ratio and p-value.
        log2_OR_matrix[i, j] <- log2(test_result$estimate)
        pvalue_matrix[i, j] <- test_result$p.value
      } else {
        # Assign NA values to the pair with insufficient diversity.
        log2_OR_matrix[i, j] <- NA
        pvalue_matrix[i, j] <- NA
      }
    }
  }
  
  # Apply FDR correction to p-values to get q-values.
  qvalue_matrix <- p.adjust(pvalue_matrix, method = "fdr")
  
  # Melt the log2_OR_matrix to create a data frame
  # that can be used in ggplot.
  finaldf <- reshape2::melt(log2_OR_matrix)
  
  # Add the q-values as a new column in this data frame.
  finaldf$qvalue <- reshape2::melt(qvalue_matrix)$value
  
  # Rename columns.
  names(finaldf) <- c("GENE_A", "GENE_B", "value", "qvalue")
  
  # Convert factors to characters to allow for comparison.
  finaldf$GENE_A <- as.character(finaldf$GENE_A)
  finaldf$GENE_B <- as.character(finaldf$GENE_B)
  # Filter data to keep only the lower half of the matrix.
  finaldf <- finaldf[finaldf$GENE_A <= finaldf$GENE_B, ]
  
  # Replace self-correlation values with NA.
  # Strip counts from gene names.
  GENE_A_without_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_A)
  GENE_B_without_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_B)
  # print(head(finaldf))                                        
  # Replace self-correlation values with NA.
  finaldf$value <- ifelse(GENE_A_without_counts == GENE_B_without_counts, NA, finaldf$value)
  finaldf$qvalue <- ifelse(GENE_A_without_counts == GENE_B_without_counts, NA, finaldf$qvalue)
  finaldf$value <- ifelse(GENE_B_without_counts == GENE_A_without_counts, NA, finaldf$value)
  finaldf$qvalue <- ifelse(GENE_B_without_counts == GENE_A_without_counts, NA, finaldf$qvalue)
  # Replace infinite values with 0.
  finaldf <- finaldf %>% mutate(value = ifelse(is.infinite(value), 0, value))
  
  # Transpose the finaldf data frame
  finaldf <- finaldf[order(finaldf$GENE_A, decreasing = FALSE), ]
  finaldf <- finaldf[order(finaldf$GENE_B, decreasing = FALSE), ]
  finaldf$GENE_A_no_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_A)
  finaldf$GENE_B_no_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_B)
  if (pathway) {
    finaldf$GENE_A_no_counts <- factor(finaldf$GENE_A_no_counts, levels = pathway_order)
    finaldf$GENE_B_no_counts <- factor(finaldf$GENE_B_no_counts, levels = pathway_order)
  } else {
    finaldf$GENE_A_no_counts <- factor(finaldf$GENE_A_no_counts, levels = genes_order)
    finaldf$GENE_B_no_counts <- factor(finaldf$GENE_B_no_counts, levels = genes_order)
  }                                              
  # Create a heatmap of the log2 odds ratios.
  plot <- ggplot(finaldf, 
                 aes_string(
                   y = "GENE_B", 
                   x = "GENE_A", 
                   fill = "value"
                 )) + 
    geom_tile(color = "black") + 
    scale_fill_gradient2(low = "#710193", 
                         high = "darkgreen", 
                         mid = "white", 
                         midpoint = 0, 
                         limits = c(-3,3), 
                         name = "log2(OR)",
                         breaks = c(-3, 0, 3),
                         oob = scales::squish,  # Values outside of limits are squished to the closest limit
                         labels = c("Mutually exclusive", "    ","Co-occurring"),
                         guide = guide_colorbar(direction = "horizontal", title.position = "top", 
                                              title.hjust = 0.5,        # Center the title horizontally
                                              title.size = 20,          # Increase font size of the title
                                              # keywidth = unit(50, "cm"), # Increase width of the legend key
                                              # keyheight = unit(15, "cm")
                                              )) + 
    
    # Add significance stars
    geom_text(data = subset(finaldf, qvalue <= 0.05), 
              aes(label = ifelse(qvalue <= 0.001, "***", ifelse(qvalue <= 0.01, "**", ifelse(qvalue <= 0.05, "*", "")))), 
              color = "white", size = 11, vjust = 0.75) +
    
    # Move x-axis to the bottom and remove labels
    scale_x_discrete(position = "top") + #ifelse(pathway, "bottom", "top")) +
    # scale_y_discrete(position = ifelse(pathway, "right", "left"))+
    labs(x = NULL, y = NULL) + 
    
    # Apply classic theme and remove panel border, axis ticks and axis lines
    theme_classic() + 
    theme(axis.text.x = element_text(angle = 45, hjust = ifelse(pathway, 1, 0.1), size = 18),
          axis.text.y = element_text(size = 18),  # Decrease row names font size
          panel.border = element_blank(),
          axis.ticks = element_blank(),
          axis.line = element_blank(),
          plot.margin = margin(1, 1, 1, 1, "cm"),
          legend.text = element_text(size = 30),
          legend.title = element_text(size = 40), # Increase font size of the legend title
          # Move legend inside plot
          # keywidth = unit(2.5, "cm"),
          # keyheight = unit(1, "cm"),
          legend.position = legend_position,
          legend.key.width = unit(2, "cm"),    # Increase the width of the legend key
          legend.key.height = unit(1, "cm"))  # Increase the height of the legend key)
    
    # Adjust the size of the legend key
    # guides(fill = guide_legend(override.aes = list(width = unit(2.5, "cm"), height = unit(1, "cm"))))
  
  # Flip coordinates if pathway argument is TRUE
  if (pathway) {
    plot <- plot + coord_flip()
  }
  return(plot)
}

number_pairs <- 0

num_rows <- length(prim_11)
if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)
for (i in 1:num_rows) {
  sample_ID[i] <- async_type_studied[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired)
distinct_patients <- unique(patient_ID)

first_pair <- c()
second_pair <- c()

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
  
  # values in prim_sync_3 that have the same patient ID as distinct_patients[i]
  sync_version <- prim_sync_11
  values_in_sync <- sync_version[grep(distinct_patients[i], sync_version)]

  if(length(values_in_sync) > 0) {
    for (j in 1:nrow(subset_table)) {
      for(k in 1:length(values_in_sync)) {
        sync_sample <- values_in_sync[k]
        patient_ID_index <- which(Dates$SAMPLE_ID == sync_sample)
        sync_date <- Dates$START_DATE[patient_ID_index]
        if(sync_date > subset_table$date_acquired[j]) {
          sample_one <- subset_table$sample_ID[j]
          sample_two <- sync_sample
        }
        else{
          sample_one <- sync_sample
          sample_two <- subset_table$sample_ID[j]
        }
        row_ind_j <- which(Clinical$SAMPLE_ID == sample_one)
        row_ind_k <- which(Clinical$SAMPLE_ID == sample_two)

        if((Clinical$TUMOR_PURITY[row_ind_j] > 20) & (Clinical$TUMOR_PURITY[row_ind_k] > 20)) {
          if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
            first_pair <- append(first_pair, sample_one)
            second_pair <- append(second_pair, sample_two)
            number_pairs <- number_pairs + 1
          }
        }
      }
    }
  }
  
  if(nrow(subset_table) == 1) {
    next
  }
  for (j in 1:(nrow(subset_table) - 1)) {
    for (k in (j+1):(nrow(subset_table))) {
      sample_one <- subset_table$sample_ID[j]
      sample_two <- subset_table$sample_ID[k]
      row_ind_j <- which(Clinical$SAMPLE_ID == sample_one)
      row_ind_k <- which(Clinical$SAMPLE_ID == sample_two)
      
      if((Clinical$TUMOR_PURITY[row_ind_j] <= 20) | (Clinical$TUMOR_PURITY[row_ind_k] <= 20) | (Clinical$TUMOR_PURITY[row_ind_j] == 5)) {
        next
      }
      # if((grepl("Oncogenic", MAF$ONCOGENIC[sample_one_index])) & (grepl("Oncogenic", MAF$ONCOGENIC[sample_two_index]))) {
      if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
        first_pair <- append(first_pair, sample_one)
        second_pair <- append(second_pair, sample_two)
        number_pairs <- number_pairs + 1
      }
    }
  }
}

# Subset the matrix to include only the desired columns
async_matrix_1 <- oncogenic_tab[, colnames(oncogenic_tab) %in% first_pair]
# zero_rows <- which(rowSums(async_matrix_1 == 0) == ncol(async_matrix_1))
# async_matrix_1 <- async_matrix_1[-zero_rows, ]


async_matrix_2 <- oncogenic_tab[, colnames(oncogenic_tab) %in% second_pair]
# zero_rows <- which(rowSums(async_matrix_2 == 0) == ncol(async_matrix_2))
# async_matrix_2 <- async_matrix_2[-zero_rows, ]

unique_indices <- unique(c(rownames(async_matrix_1), rownames(async_matrix_2)))

async_matrix_1 <- async_matrix_1[rownames(async_matrix_1) %in% unique_indices, ]
async_matrix_2 <- async_matrix_2[rownames(async_matrix_2) %in% unique_indices, ]

# Transpose the matrices
t_async_matrix_1 <- t(async_matrix_1)
t_async_matrix_2 <- t(async_matrix_2)

col_counts_1 <- colSums(t_async_matrix_1)
col_counts_2 <- colSums(t_async_matrix_2)

t_async_matrix_1 <- t_async_matrix_1[, (col_counts_1 >= 3) | (col_counts_2 >= 3)]
t_async_matrix_2 <- t_async_matrix_2[, (col_counts_1 >= 3) | (col_counts_2 >= 3)]



plot <- FromGAMtoPlot(t_async_matrix_1, pathway = FALSE)
plot

# plot <- FromGAMtoPlot(t_async_matrix_2, pathway = FALSE)
# plot
```


```{r}
# asynchronous but adjusting so asynchronous pairs are those with greatest time elapsed
FromGAMtoPlot <- function(df, pathway = FALSE) {
  # if (!pathway) {
  #   # Remove mutations with n=3
  #   col_counts <- colSums(df)
  #   df <- df[, col_counts >= 3]
  # }
  
  # The dataframe (df) should be a binary matrix where rows are samples, columns are genes, and each entry is 0 or 1.
  # If pathway is TRUE, sum the alterations at the pathway level.
  if (pathway) {
    gene_to_pathway <- read.table("~/Downloads/Pathway_Groupings.txt", sep = '\t', header = TRUE) %>% drop_na()
    # Store order of Pathway column
    pathway_order <- unique(gene_to_pathway$Pathway)
    # Define the pathways for each gene.
    # Transpose the dataframe to have genes as rows and samples as columns
    df <- as.data.frame(t(df))
    # Join the input data frame with the gene_to_pathway data frame to add a Pathway column
    df <- merge(df, gene_to_pathway, by.x = "row.names", by.y = "Hugo_symbol")
    row.names(df) <- df$Row.names  # Preserve the original row names
    df$Row.names <- NULL
    # Sum the alterations at the pathway level
    df <- df %>% group_by(Pathway) %>% summarise_all(function(x) as.integer(sum(x) > 0))
    df <- ungroup(df)
    # Print the total number of alterations per pathway
    total_alterations <- rowSums(df[,-1])  # Excluding the 'Pathway' column
    df$Total_alterations <- total_alterations
    # print(df %>% select(Pathway, Total_alterations))
    
    df <- df %>% column_to_rownames(var = "Pathway")    # Replace the row names with the pathway names
    df$Total_alterations <- NULL  # Remove the 'Total_alterations' column before transposing
    df <- as.data.frame(t(df))
  }
  
  # Store a copy of the original genes or pathways
  original_genes_or_pathways <- colnames(df)
  # Extract column names, assumed to be gene names.
  genes <- colnames(df)
  genes_order <- genes
  
  # Count the alterations for each gene.
  gene_counts <- colSums(df > 0)
  genes_with_counts <- paste0(genes, " (n = ", gene_counts, ")")
  
  # Initialize matrices to store the log2 odds ratios and p-values.
  log2_OR_matrix <- matrix(nrow = length(genes), ncol = length(genes))
  pvalue_matrix <- matrix(nrow = length(genes), ncol = length(genes))
  
  if (pathway) {
    # legend position and title for pathway
    legend_position <- c(.22, .75)
    legend_labels <- c("Co-occurring", " ","Mutually exclusive")
    y_labels <- genes  # 'y' axis labels with counts
    x_labels <- genes_with_counts               # 'x' axis labels without counts
    
    rownames(log2_OR_matrix) <- x_labels  
    colnames(log2_OR_matrix) <- y_labels              
    rownames(pvalue_matrix) <- x_labels  
    colnames(pvalue_matrix) <- y_labels 
    # print(head(log2_OR_matrix))
  } else {
    # legend position and title for gene
    legend_position <- c(.78, .32)
    legend_labels <- c("Mutually exclusive", "    ","Co-occurring")
    y_labels <- genes   # 'y' axis labels without counts
    x_labels <- genes_with_counts   # 'x' axis labels with counts
    
    rownames(log2_OR_matrix) <- y_labels  
    colnames(log2_OR_matrix) <- x_labels              
    rownames(pvalue_matrix) <- y_labels  
    colnames(pvalue_matrix) <- x_labels 
    # print(head(log2_OR_matrix))
    
  }
  
  # Loop over all possible pairs of genes.
  for (i in seq_along(genes)) {
    for (j in seq_along(genes)) {
      # Only proceed if both genes have at least 2 distinct values.
      if (length(unique(df[, genes[i]])) > 1 && length(unique(df[, genes[j]])) > 1) {
        # Create a contingency table of the presence/absence patterns of the two genes.
        table <- table(df[, genes[i]], df[, genes[j]])
        # Conduct Fisher's exact test on the contingency table.
        test_result <- fisher.test(table)
        # Extract the log2 odds ratio and p-value.
        log2_OR_matrix[i, j] <- log2(test_result$estimate)
        pvalue_matrix[i, j] <- test_result$p.value
      } else {
        # Assign NA values to the pair with insufficient diversity.
        log2_OR_matrix[i, j] <- NA
        pvalue_matrix[i, j] <- NA
      }
    }
  }
  
  # Apply FDR correction to p-values to get q-values.
  qvalue_matrix <- p.adjust(pvalue_matrix, method = "fdr")
  
  # Melt the log2_OR_matrix to create a data frame
  # that can be used in ggplot.
  finaldf <- reshape2::melt(log2_OR_matrix)
  
  # Add the q-values as a new column in this data frame.
  finaldf$qvalue <- reshape2::melt(qvalue_matrix)$value
  
  # Rename columns.
  names(finaldf) <- c("GENE_A", "GENE_B", "value", "qvalue")
  
  # Convert factors to characters to allow for comparison.
  finaldf$GENE_A <- as.character(finaldf$GENE_A)
  finaldf$GENE_B <- as.character(finaldf$GENE_B)
  # Filter data to keep only the lower half of the matrix.
  finaldf <- finaldf[finaldf$GENE_A <= finaldf$GENE_B, ]
  
  # Replace self-correlation values with NA.
  # Strip counts from gene names.
  GENE_A_without_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_A)
  GENE_B_without_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_B)
  # print(head(finaldf))                                        
  # Replace self-correlation values with NA.
  finaldf$value <- ifelse(GENE_A_without_counts == GENE_B_without_counts, NA, finaldf$value)
  finaldf$qvalue <- ifelse(GENE_A_without_counts == GENE_B_without_counts, NA, finaldf$qvalue)
  finaldf$value <- ifelse(GENE_B_without_counts == GENE_A_without_counts, NA, finaldf$value)
  finaldf$qvalue <- ifelse(GENE_B_without_counts == GENE_A_without_counts, NA, finaldf$qvalue)
  # Replace infinite values with 0.
  finaldf <- finaldf %>% mutate(value = ifelse(is.infinite(value), 0, value))
  
  # Transpose the finaldf data frame
  finaldf <- finaldf[order(finaldf$GENE_A, decreasing = FALSE), ]
  finaldf <- finaldf[order(finaldf$GENE_B, decreasing = FALSE), ]
  finaldf$GENE_A_no_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_A)
  finaldf$GENE_B_no_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_B)
  if (pathway) {
    finaldf$GENE_A_no_counts <- factor(finaldf$GENE_A_no_counts, levels = pathway_order)
    finaldf$GENE_B_no_counts <- factor(finaldf$GENE_B_no_counts, levels = pathway_order)
  } else {
    finaldf$GENE_A_no_counts <- factor(finaldf$GENE_A_no_counts, levels = genes_order)
    finaldf$GENE_B_no_counts <- factor(finaldf$GENE_B_no_counts, levels = genes_order)
  }                                              
  # Create a heatmap of the log2 odds ratios.
  plot <- ggplot(finaldf, 
                 aes_string(
                   y = "GENE_B", 
                   x = "GENE_A", 
                   fill = "value"
                 )) + 
    geom_tile(color = "black") + 
    scale_fill_gradient2(low = "#710193", 
                         high = "darkgreen", 
                         mid = "white", 
                         midpoint = 0, 
                         limits = c(-3,3), 
                         name = "log2(OR)",
                         breaks = c(-3, 0, 3),
                         oob = scales::squish,  # Values outside of limits are squished to the closest limit
                         labels = c("Mutually exclusive", "    ","Co-occurring"),
                         guide = guide_colorbar(direction = "horizontal", title.position = "top", 
                                              title.hjust = 0.5,        # Center the title horizontally
                                              title.size = 20,          # Increase font size of the title
                                              # keywidth = unit(50, "cm"), # Increase width of the legend key
                                              # keyheight = unit(15, "cm")
                                              )) + 
    
    # Add significance stars
    geom_text(data = subset(finaldf, qvalue <= 0.05), 
              aes(label = ifelse(qvalue <= 0.001, "***", ifelse(qvalue <= 0.01, "**", ifelse(qvalue <= 0.05, "*", "")))), 
              color = "white", size = 18, vjust = 0.75) +
    
    # Move x-axis to the bottom and remove labels
    scale_x_discrete(position = "top") + #ifelse(pathway, "bottom", "top")) +
    # scale_y_discrete(position = ifelse(pathway, "right", "left"))+
    labs(x = NULL, y = NULL) + 
    
    # Apply classic theme and remove panel border, axis ticks and axis lines
    theme_classic() + 
    theme(axis.text.x = element_text(angle = 45, hjust = ifelse(pathway, 1, 0.1), size = 20),
          axis.text.y = element_text(size = 20),  # Decrease row names font size
          panel.border = element_blank(),
          axis.ticks = element_blank(),
          axis.line = element_blank(),
          plot.margin = margin(1, 1, 1, 1, "cm"),
          legend.text = element_text(size = 30),
          legend.title = element_text(size = 40), # Increase font size of the legend title
          # Move legend inside plot
          # keywidth = unit(2.5, "cm"),
          # keyheight = unit(1, "cm"),
          legend.position = legend_position,
          legend.key.width = unit(2, "cm"),    # Increase the width of the legend key
          legend.key.height = unit(1, "cm"))  # Increase the height of the legend key)
    
    # Adjust the size of the legend key
    # guides(fill = guide_legend(override.aes = list(width = unit(2.5, "cm"), height = unit(1, "cm"))))
  
  # Flip coordinates if pathway argument is TRUE
  if (pathway) {
    plot <- plot + coord_flip()
  }
  return(plot)
}


number_pairs <- 0

cancer <- prim[[LUAD]]
num_rows <- length(cancer)

if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)
for (i in 1:num_rows) {
  sample_ID[i] <- cancer[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired)
distinct_patients <- unique(patient_ID)

first_pair <- c()
second_pair <- c()

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
   
  if(nrow(subset_table) <= 1) {
    next
  }
  
  if(subset_table$date_acquired[nrow(subset_table)] - subset_table$date_acquired[1] < ASYNC_MARK){
    next
  }
  
  # result <- find_two_pairs_with_greatest_difference(subset_table, "date_acquired", ASYNC_MAX_DIFF)
  
  sample_one <- subset_table$sample_ID[1]
  sample_two <- subset_table$sample_ID[nrow(subset_table)]
  
  row_ind_j <- which(Clinical$SAMPLE_ID == sample_one)
  row_ind_k <- which(Clinical$SAMPLE_ID == sample_two)
  
  if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
    first_pair <- append(first_pair, sample_one)
    second_pair <- append(second_pair, sample_two)
    number_pairs <- number_pairs + 1
  }
}

# Subset the matrix to include only the desired columns
async_matrix_1 <- oncogenic_tab[, colnames(oncogenic_tab) %in% first_pair]
# zero_rows <- which(rowSums(async_matrix_1 == 0) == ncol(async_matrix_1))
# async_matrix_1 <- async_matrix_1[-zero_rows, ]


async_matrix_2 <- oncogenic_tab[, colnames(oncogenic_tab) %in% second_pair]
# zero_rows <- which(rowSums(async_matrix_2 == 0) == ncol(async_matrix_2))
# async_matrix_2 <- async_matrix_2[-zero_rows, ]

unique_indices <- unique(c(rownames(async_matrix_1), rownames(async_matrix_2)))

async_matrix_1 <- async_matrix_1[rownames(async_matrix_1) %in% unique_indices, ]
async_matrix_2 <- async_matrix_2[rownames(async_matrix_2) %in% unique_indices, ]

# Transpose the matrices
t_async_matrix_1 <- t(async_matrix_1)
t_async_matrix_2 <- t(async_matrix_2)

col_counts_1 <- colSums(t_async_matrix_1)
col_counts_2 <- colSums(t_async_matrix_2)

t_async_matrix_1 <- t_async_matrix_1[, (col_counts_1 >= 3) | (col_counts_2 >= 3)]
t_async_matrix_2 <- t_async_matrix_2[, (col_counts_1 >= 3) | (col_counts_2 >= 3)]

plot <- FromGAMtoPlot(t_async_matrix_2, pathway = FALSE)
plot
```

```{r}
# synchronous heatmap selecting pairs from a single patients that have the shortest time elapsed
FromGAMtoPlot <- function(df, pathway = FALSE) {
  # if (!pathway) {
  #   # Remove mutations with n=3
  #   col_counts <- colSums(df)
  #   df <- df[, col_counts >= 3]
  # }
  
  # The dataframe (df) should be a binary matrix where rows are samples, columns are genes, and each entry is 0 or 1.
  # If pathway is TRUE, sum the alterations at the pathway level.
  if (pathway) {
    gene_to_pathway <- read.table("~/Downloads/Pathway_Groupings.txt", sep = '\t', header = TRUE) %>% drop_na()
    # Store order of Pathway column
    pathway_order <- unique(gene_to_pathway$Pathway)
    # Define the pathways for each gene.
    # Transpose the dataframe to have genes as rows and samples as columns
    df <- as.data.frame(t(df))
    # Join the input data frame with the gene_to_pathway data frame to add a Pathway column
    df <- merge(df, gene_to_pathway, by.x = "row.names", by.y = "Hugo_symbol")
    row.names(df) <- df$Row.names  # Preserve the original row names
    df$Row.names <- NULL
    # Sum the alterations at the pathway level
    df <- df %>% group_by(Pathway) %>% summarise_all(function(x) as.integer(sum(x) > 0))
    df <- ungroup(df)
    # Print the total number of alterations per pathway
    total_alterations <- rowSums(df[,-1])  # Excluding the 'Pathway' column
    df$Total_alterations <- total_alterations
    # print(df %>% select(Pathway, Total_alterations))
    
    df <- df %>% column_to_rownames(var = "Pathway")    # Replace the row names with the pathway names
    df$Total_alterations <- NULL  # Remove the 'Total_alterations' column before transposing
    df <- as.data.frame(t(df))
  }
  
  # Store a copy of the original genes or pathways
  original_genes_or_pathways <- colnames(df)
  # Extract column names, assumed to be gene names.
  genes <- colnames(df)
  genes_order <- genes
  
  # Count the alterations for each gene.
  gene_counts <- colSums(df > 0)
  genes_with_counts <- paste0(genes, " (n = ", gene_counts, ")")
  
  # Initialize matrices to store the log2 odds ratios and p-values.
  log2_OR_matrix <- matrix(nrow = length(genes), ncol = length(genes))
  pvalue_matrix <- matrix(nrow = length(genes), ncol = length(genes))
  
  if (pathway) {
    # legend position and title for pathway
    legend_position <- c(.22, .75)
    legend_labels <- c("Co-occurring", " ","Mutually exclusive")
    y_labels <- genes  # 'y' axis labels with counts
    x_labels <- genes_with_counts               # 'x' axis labels without counts
    
    rownames(log2_OR_matrix) <- x_labels  
    colnames(log2_OR_matrix) <- y_labels              
    rownames(pvalue_matrix) <- x_labels  
    colnames(pvalue_matrix) <- y_labels 
    # print(head(log2_OR_matrix))
  } else {
    # legend position and title for gene
    legend_position <- c(.78, .32)
    legend_labels <- c("Mutually exclusive", "    ","Co-occurring")
    y_labels <- genes   # 'y' axis labels without counts
    x_labels <- genes_with_counts   # 'x' axis labels with counts
    
    rownames(log2_OR_matrix) <- y_labels  
    colnames(log2_OR_matrix) <- x_labels              
    rownames(pvalue_matrix) <- y_labels  
    colnames(pvalue_matrix) <- x_labels 
    # print(head(log2_OR_matrix))
    
  }
  
  # Loop over all possible pairs of genes.
  for (i in seq_along(genes)) {
    for (j in seq_along(genes)) {
      # Only proceed if both genes have at least 2 distinct values.
      if (length(unique(df[, genes[i]])) > 1 && length(unique(df[, genes[j]])) > 1) {
        # Create a contingency table of the presence/absence patterns of the two genes.
        table <- table(df[, genes[i]], df[, genes[j]])
        # Conduct Fisher's exact test on the contingency table.
        test_result <- fisher.test(table)
        # Extract the log2 odds ratio and p-value.
        log2_OR_matrix[i, j] <- log2(test_result$estimate)
        pvalue_matrix[i, j] <- test_result$p.value
      } else {
        # Assign NA values to the pair with insufficient diversity.
        log2_OR_matrix[i, j] <- NA
        pvalue_matrix[i, j] <- NA
      }
    }
  }
  
  # Apply FDR correction to p-values to get q-values.
  qvalue_matrix <- p.adjust(pvalue_matrix, method = "fdr")
  
  # Melt the log2_OR_matrix to create a data frame
  # that can be used in ggplot.
  finaldf <- reshape2::melt(log2_OR_matrix)
  
  # Add the q-values as a new column in this data frame.
  finaldf$qvalue <- reshape2::melt(qvalue_matrix)$value
  
  # Rename columns.
  names(finaldf) <- c("GENE_A", "GENE_B", "value", "qvalue")
  
  # Convert factors to characters to allow for comparison.
  finaldf$GENE_A <- as.character(finaldf$GENE_A)
  finaldf$GENE_B <- as.character(finaldf$GENE_B)
  # Filter data to keep only the lower half of the matrix.
  finaldf <- finaldf[finaldf$GENE_A <= finaldf$GENE_B, ]
  
  # Replace self-correlation values with NA.
  # Strip counts from gene names.
  GENE_A_without_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_A)
  GENE_B_without_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_B)
  # print(head(finaldf))                                        
  # Replace self-correlation values with NA.
  finaldf$value <- ifelse(GENE_A_without_counts == GENE_B_without_counts, NA, finaldf$value)
  finaldf$qvalue <- ifelse(GENE_A_without_counts == GENE_B_without_counts, NA, finaldf$qvalue)
  finaldf$value <- ifelse(GENE_B_without_counts == GENE_A_without_counts, NA, finaldf$value)
  finaldf$qvalue <- ifelse(GENE_B_without_counts == GENE_A_without_counts, NA, finaldf$qvalue)
  # Replace infinite values with 0.
  finaldf <- finaldf %>% mutate(value = ifelse(is.infinite(value), 0, value))
  
  # Transpose the finaldf data frame
  finaldf <- finaldf[order(finaldf$GENE_A, decreasing = FALSE), ]
  finaldf <- finaldf[order(finaldf$GENE_B, decreasing = FALSE), ]
  finaldf$GENE_A_no_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_A)
  finaldf$GENE_B_no_counts <- sub(" \\(n = .*\\)", "", finaldf$GENE_B)
  if (pathway) {
    finaldf$GENE_A_no_counts <- factor(finaldf$GENE_A_no_counts, levels = pathway_order)
    finaldf$GENE_B_no_counts <- factor(finaldf$GENE_B_no_counts, levels = pathway_order)
  } else {
    finaldf$GENE_A_no_counts <- factor(finaldf$GENE_A_no_counts, levels = genes_order)
    finaldf$GENE_B_no_counts <- factor(finaldf$GENE_B_no_counts, levels = genes_order)
  }                                              
  # Create a heatmap of the log2 odds ratios.
  plot <- ggplot(finaldf, 
                 aes_string(
                   y = "GENE_B", 
                   x = "GENE_A", 
                   fill = "value"
                 )) + 
    geom_tile(color = "black") + 
    scale_fill_gradient2(low = "#710193", 
                         high = "darkgreen", 
                         mid = "white", 
                         midpoint = 0, 
                         limits = c(-3,3), 
                         name = "log2(OR)",
                         breaks = c(-3, 0, 3),
                         oob = scales::squish,  # Values outside of limits are squished to the closest limit
                         labels = c("Mutually exclusive", "    ","Co-occurring"),
                         guide = guide_colorbar(direction = "horizontal", title.position = "top", 
                                              title.hjust = 0.5,        # Center the title horizontally
                                              title.size = 20,          # Increase font size of the title
                                              # keywidth = unit(50, "cm"), # Increase width of the legend key
                                              # keyheight = unit(15, "cm")
                                              )) + 
    
    # Add significance stars
    geom_text(data = subset(finaldf, qvalue <= 0.05), 
              aes(label = ifelse(qvalue <= 0.001, "***", ifelse(qvalue <= 0.01, "**", ifelse(qvalue <= 0.05, "*", "")))), 
              color = "white", size = 25, vjust = 0.75) +
    
    # Move x-axis to the bottom and remove labels
    scale_x_discrete(position = "top") + #ifelse(pathway, "bottom", "top")) +
    # scale_y_discrete(position = ifelse(pathway, "right", "left"))+
    labs(x = NULL, y = NULL) + 
    
    # Apply classic theme and remove panel border, axis ticks and axis lines
    theme_classic() + 
    theme(axis.text.x = element_text(angle = 45, hjust = ifelse(pathway, 1, 0.1), size = 30),
          axis.text.y = element_text(size = 30),  # Decrease row names font size
          panel.border = element_blank(),
          axis.ticks = element_blank(),
          axis.line = element_blank(),
          plot.margin = margin(1, 1, 1, 1, "cm"),
          legend.text = element_text(size = 30),
          legend.title = element_text(size = 40), # Increase font size of the legend title
          # Move legend inside plot
          # keywidth = unit(2.5, "cm"),
          # keyheight = unit(1, "cm"),
          legend.position = legend_position,
          legend.key.width = unit(2, "cm"),    # Increase the width of the legend key
          legend.key.height = unit(1, "cm"))  # Increase the height of the legend key)
    
    # Adjust the size of the legend key
    # guides(fill = guide_legend(override.aes = list(width = unit(2.5, "cm"), height = unit(1, "cm"))))
  
  # Flip coordinates if pathway argument is TRUE
  if (pathway) {
    plot <- plot + coord_flip()
  }
  return(plot)
}


number_pairs <- 0

cancer <- prim[[LUAD]]
num_rows <- length(cancer)

if(num_rows < 1) {next}

# create empty vectors for each column
sample_ID <- character(num_rows)
patient_ID <- character(num_rows)
date_acquired <- integer(num_rows)
for (i in 1:num_rows) {
  sample_ID[i] <- cancer[i]
  clin_ind <- which(Clinical$SAMPLE_ID == sample_ID[i])
  patient_ID[i] <- Clinical$PATIENT_ID[clin_ind]
  patient_ID_index <- which(Dates$SAMPLE_ID == sample_ID[i])
  date_acquired[i] <- Dates$START_DATE[patient_ID_index]
}

# create a table with 3 columns and length(cancer_type_studied) rows
table <- data.frame(sample_ID, patient_ID, date_acquired)
distinct_patients <- unique(patient_ID)

first_pair <- c()
second_pair <- c()

for (i in 1:length(distinct_patients)) {
  subset_table <- subset(table, patient_ID == distinct_patients[i])
  subset_table <- subset_table[order(subset_table$date_acquired),]
   
  if(nrow(subset_table) <= 1) {
    next
  }
  
  if(subset_table$date_acquired[nrow(subset_table)] - subset_table$date_acquired[1] > SYNC_MARK){
    next
  }
  # Initialize variables to store the information about the shortest pair
  shortest_time_diff <- Inf
  shortest_pair <- c()
  
  # Iterate through all possible pairs of entries
  for (i in 1:(nrow(subset_table) - 1)) {
    for (j in (i + 1):nrow(subset_table)) {
      time_diff <- abs(subset_table$date_acquired[i] - subset_table$date_acquired[j])
      if (time_diff < shortest_time_diff) {
        shortest_time_diff <- time_diff
        shortest_pair <- c(subset_table$sample_ID[i], subset_table$sample_ID[j])
      }
    }
  }
  
  sample_one <- shortest_pair[1]
  sample_two <- shortest_pair[2]
  
  row_ind_j <- which(Clinical$SAMPLE_ID == sample_one)
  row_ind_k <- which(Clinical$SAMPLE_ID == sample_two)
  
  if((sample_one %in% colnames(oncogenic_tab)) & (sample_two %in% colnames(oncogenic_tab))){
    first_pair <- append(first_pair, sample_one)
    second_pair <- append(second_pair, sample_two)
    number_pairs <- number_pairs + 1
  }
}

# Subset the matrix to include only the desired columns
async_matrix_1 <- oncogenic_tab[, colnames(oncogenic_tab) %in% first_pair]
# zero_rows <- which(rowSums(async_matrix_1 == 0) == ncol(async_matrix_1))
# async_matrix_1 <- async_matrix_1[-zero_rows, ]


async_matrix_2 <- oncogenic_tab[, colnames(oncogenic_tab) %in% second_pair]
# zero_rows <- which(rowSums(async_matrix_2 == 0) == ncol(async_matrix_2))
# async_matrix_2 <- async_matrix_2[-zero_rows, ]

unique_indices <- unique(c(rownames(async_matrix_1), rownames(async_matrix_2)))

async_matrix_1 <- async_matrix_1[rownames(async_matrix_1) %in% unique_indices, ]
async_matrix_2 <- async_matrix_2[rownames(async_matrix_2) %in% unique_indices, ]

# Transpose the matrices
t_async_matrix_1 <- t(async_matrix_1)
t_async_matrix_2 <- t(async_matrix_2)

col_counts_1 <- colSums(t_async_matrix_1)
col_counts_2 <- colSums(t_async_matrix_2)

t_async_matrix_1 <- t_async_matrix_1[, (col_counts_1 >= 3) | (col_counts_2 >= 3)]
t_async_matrix_2 <- t_async_matrix_2[, (col_counts_1 >= 3) | (col_counts_2 >= 3)]

plot <- FromGAMtoPlot(t_async_matrix_1, pathway = FALSE)
plot
```